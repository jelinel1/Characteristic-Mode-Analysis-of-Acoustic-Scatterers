% This LaTeX was auto-generated from MATLAB code.
% To make changes, update the MATLAB code and republish this document.
\documentclass[a4paper,oneside,10pt]{report}
\usepackage{graphicx}
\usepackage[outdir=./]{epstopdf}
\usepackage{color}
\definecolor{gray}{rgb}{0.3,0.3,0.3}
\definecolor{code}{rgb}{1,1,0.94}
\definecolor{syscmd}{RGB}{178,140,0}
\definecolor{keyword}{rgb}{0,0,1}
\definecolor{string}{rgb}{0.627,0.125,0.941}
\definecolor{untermstring}{rgb}{1,0,0}
\definecolor{comment}{rgb}{0,0.5,0}
\definecolor{intro}{rgb}{0.96,0.96,0.99}
\definecolor{basic1}{RGB}{34, 69, 133}
\definecolor{basic2}{RGB}{44, 145, 210}
\definecolor{basic3}{RGB}{205, 91, 28}
\definecolor{special1}{RGB}{24, 110, 159}
\definecolor{special2}{RGB}{39, 156, 220}
\definecolor{special3}{RGB}{234, 184, 24}
\definecolor{orange}{RGB}{200, 100, 0}
\usepackage{amsmath}
\usepackage{geometry}
\geometry{
a4paper,
total={210mm,297mm},
left=25mm,
right=25mm,
top=25mm,
bottom=25mm,
}
\usepackage{mdframed}
\mdfsetup{
backgroundcolor=intro,
linewidth=0pt}
\usepackage{fancyvrb} % better code
\fvset{
commandchars=\\\{\},
fontfamily=courier,
fontsize=\small
}
\newenvironment{matlabcode}{\VerbatimEnvironment%
\begin{mdframed}[backgroundcolor=code,linewidth=0.3pt]%
\begin{Verbatim}%
}{%
\end{Verbatim}%
\end{mdframed}%
}
\newenvironment{IOVerbatim}{\VerbatimEnvironment%
\vspace{-15pt}%
\begin{Verbatim}%
}{%
\end{Verbatim}%
}
\usepackage{fancyhdr} % header/footer
\usepackage{hyperref}
\hypersetup{
bookmarks=true,         % show bookmarks bar?
unicode=false,          % non-Latin characters in Acrobat's bookmarks
pdftoolbar=true,        % show Acrobat's toolbar?
pdfmenubar=true,        % show Acrobat's menu?
pdffitwindow=false,     % window fit to page when opened
pdfstartview={FitH},    % fits the width of the page to the window
pdftitle={My title},    % title
pdfauthor={Author},     % author
pdfsubject={Subject},   % subject of the document
pdfcreator={Creator},   % creator of the document
pdfproducer={Producer}, % producer of the document
pdfkeywords={keyword1} {key2} {key3}, % list of keywords
pdfnewwindow=true,      % links in new PDF window
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=orange,          % color of internal links (change box color with linkbordercolor)
citecolor=green,        % color of links to bibliography
filecolor=magenta,      % color of file links
urlcolor=blue           % color of external links
}
\urlstyle{rm}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\DeclareMathSizes{10}{9}{7}{5} % math size
\setlength{\jot}{4pt} % math line spacing
\sloppy
\definecolor{lightgray}{gray}{0.5}
\setlength{\parindent}{0pt}
\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\begin{document}
\pagenumbering{gobble}
\begin{figure}[!h]\vspace{2cm}\center
\includegraphics[width=12cm]{atom_logotyp_1-1.eps}
{\vspace{3cm}\\\Huge Documentation}\end{figure}
{\vspace{5cm}\Large \hfill 11 Jan 2024}
 \newpage
\cleardoublepage
\pagenumbering{gobble}
\tableofcontents
\newpage
\pagenumbering{arabic}
\cfoot{-~\thepage~-}
\renewcommand{\headrulewidth}{0.2pt}
\renewcommand{\footrulewidth}{0.2pt}
\lhead{\includegraphics[width=2.5cm]{atom_logotyp_2-1.eps}}
\fancypagestyle{plain}{%
\fancyhf{} % clear all header and footer fields
\cfoot{-~\thepage~-} % except the center
\lhead{\includegraphics[width=2.5cm]{atom_logotyp_2-1.eps}}
\renewcommand{\headrulewidth}{0.2pt}
\renewcommand{\footrulewidth}{0.2pt}}\cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+geom}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+geom}}~}
\fancyhead[RO,RE]{+models/+geom}\newpage
\cleardoublepage\phantomsection\addcontentsline{toc}{section}{Class +models/+geom/@Boolean}\vspace{1em}\section*{Class +models/+geom/@Boolean}
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{subtract: perform boolean operation subtract on objects}
          \vspace{1em}
          \label{AToM:+models:+geom:@Boolean:subtract}AToM:+models:+geom:@Boolean:subtract         
          \subsection*{subtract: perform boolean operation subtract on objects}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This perfoirms subtract Boolean operation on specified objects.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Boolean object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{names1}}: name of Object 1, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{names2}}: name of Object 2, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type1}}: optional, type of Object 1, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type2}}: optional, type of Object 2, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{callerName}}: optional, name of calling function, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.subtract(names1, names2)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Objects specified by \textit{names1} and \textit{names2} are subtracted.\end{par}\begin{Verbatim}
 obj.subtract(names1, names2, type1, type2, callerName)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Objects are searched faster according to hints in \textit{type1} and \textit{type2}. Valid values of \textit{callerName} are: 'recomputeCommands' (do not write to History), 'user' (write to history).\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Boolean\ensuremath{\backslash}subtract}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{unite: perform boolean operation unite on objects}
          \vspace{1em}
          \label{AToM:+models:+geom:@Boolean:unite}AToM:+models:+geom:@Boolean:unite         
          \subsection*{unite: perform boolean operation unite on objects}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This perfoirms unite Boolean operation on specified objects.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Boolean object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{names1}}: name of Object 1, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{names2}}: name of Object 2, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type1}}: optional, type of Object 1, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type2}}: optional, type of Object 2, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{callerName}}: optional, name of calling function, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.unite(names1, names2)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Objects specified by \textit{names1} and \textit{names2} are subtracted.\end{par}\begin{Verbatim}
 obj.unite(names1, names2, type1, type2, callerName)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Objects are searched faster according to hints in \textit{type1} and \textit{type2}. Valid values of \textit{callerName} are: 'recomputeCommands' (do not write to History), 'user' (write to history).\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Boolean\ensuremath{\backslash}unite}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{section}{Class +models/+geom/@Geom}\vspace{1em}\section*{Class +models/+geom/@Geom}
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addCircle: include Ellipse of circular shape to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addCircle}AToM:+models:+geom:@Geom:addCircle         
          \subsection*{addCircle: include Ellipse of circular shape to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object Ellipse to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{center}}: circle's center point, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{radius}}: circle's radius, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{normal}}: optional, rectangle's normal spec. (default 'z'), char [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addCircle(center, radius)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Ellipse specified by center point \textit{center} and \textit{radius} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addCircle(center, radius, normal)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Ellipse specified by center point \textit{center}, \textit{radius} and normal direction \textit{norm} is created in Geom.\end{par}\begin{Verbatim}
 id = obj.addCircle(center, radius, normal, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object name is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addCircle}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addCircleArc: include EllipseArc of circular shape to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addCircleArc}AToM:+models:+geom:@Geom:addCircleArc         
          \subsection*{addCircleArc: include EllipseArc of circular shape to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object EllipseArc to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{center}}: circle's center point, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{radius}}: circle's radius, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{normal}}: optional, circle's normal spec. (default 'z'), char [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addCircleArc(center, radius)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type EllipseArc specified by center point \textit{center} and \textit{radius} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addCircleArc(center, radius, normal)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type EllipseArc specified by center point \textit{center}, \textit{radius} and normal direction \textit{norm} is created in Geom.\end{par}\begin{Verbatim}
 id = obj.addCircleArc(center, radius, normal, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object name is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addCircleArc}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addEllipse: include Ellipse to Geom object container}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addEllipse}AToM:+models:+geom:@Geom:addEllipse         
          \subsection*{addEllipse: include Ellipse to Geom object container}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object Ellipse to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{cP}}: center point, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{majV}}: major axis vertex point, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{minV}}: minor axis vertex point, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{sA}}: start angle of Ellipse, char [1 x N]/double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{a}}: angle of Ellipse, char [1 x N]/double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addEllipse(cP, majV, minV, sA, a)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Ellipse specified by \textit{cP}, \textit{majV}, \textit{minV, \_sA} and \textit{a} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addEllipse(cP, majV, minV, sA, a, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Ellipse specified by \textit{cP}, \textit{majV}, \textit{minV, \_sA} and \textit{a} is created in Geom. The name of new object is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addEllipse}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addEllipseArc: include EllipseArc to Geom object container}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addEllipseArc}AToM:+models:+geom:@Geom:addEllipseArc         
          \subsection*{addEllipseArc: include EllipseArc to Geom object container}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object EllipseArc to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{cP}}: center point, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{majV}}: major axis vertex point, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{minV}}: minor axis vertex point, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{sA}}: start angle of EllipseArc, char [1 x N]/double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{a}}: angle of EllipseArc, char [1 x N]/double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addEllipseArc(cP, majV, minV, sA, a)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type EllipseArc specified by \textit{cP}, \textit{majV}, \textit{minV, \_sA} and \textit{a} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addEllipseArc(cP, majV, minV, sA, a, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type EllipseArc specified by \textit{cP}, \textit{majV}, \textit{minV, \_sA} and \textit{a} is created in Geom. The name of new object is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addEllipseArc}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addEquatoionCurve: include EquatoionCurve to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addEquationCurve}AToM:+models:+geom:@Geom:addEquationCurve         
          \subsection*{addEquatoionCurve: include EquatoionCurve to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object EquatoionCurve to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eqX}}: handle function to X coordinate, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eqY}}: handle function to Y coordinate, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eqZ}}: handle function to Z coordinate, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{parInt}}: interval for parameter, char [1 x N]/double [1 x 2]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \vspace{2pt}\begin{par}The object of type EquatoionCurve specified by handle functions \textit{eqX}, \textit{eqY}, \textit{eqZ and parameter interval \_parInt} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addLine(points, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type EquatoionCurve specified by handle functions \textit{eqX}, \textit{eqY}, \textit{eqZ and parameter interval \_parInt} is created in Geom. The name of new object is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addEquationCurve}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addLine: include Line to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addLine}AToM:+models:+geom:@Geom:addLine         
          \subsection*{addLine: include Line to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object Line to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: expression for coordinates definition, char [1 x N]/double [2 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addLine(points)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Line with start and end points specified by \textit{points} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addLine(points, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Line with start and end points specified by \textit{points} is created in Geom. The name of new object is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addLine}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addParallelogram: include Parallelogram to Geom object container}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addParallelogram}AToM:+models:+geom:@Geom:addParallelogram         
          \subsection*{addParallelogram: include Parallelogram to Geom object container}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object Parallelogram to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{lLC}}: low left corner position, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{lRC}}: low right corner position, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{hLC}}: high left corner position, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addParallelogram(lLC, lRC, hLC)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Parallelogram specified by three corners \textit{lLC}, \textit{lRC}, \textit{hLC} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addParallelogram(lLC, lRC, hLC, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Parallelogram specified by \textit{lLC}, \textit{lRC}, \textit{hLC} is created in Geom. The name of new object is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addParallelogram}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addParallelogramFrame: include ParallelogramFrame to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addParallelogramFrame}AToM:+models:+geom:@Geom:addParallelogramFrame         
          \subsection*{addParallelogramFrame: include ParallelogramFrame to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object ParallelogramFrame to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{lLC}}: low left corner, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{lRC}}: low right corner, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{hLC}}: high left corner, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addParallelogramFrame(lLC, lRC, hLC)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type ParallelogramFrame specified by three corners \textit{lLC}, \textit{lRC}, \_hLC is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addParallelogramFrame(lLC, lRC, hLC, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type ParallelogramFrame specified by three corners \textit{lLC}, \textit{lRC}, \textit{hLC is created in Geom. The name of new object is set to \_name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addParallelogramFrame}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addPoint: include Point to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addPoint}AToM:+models:+geom:@Geom:addPoint         
          \subsection*{addPoint: include Point to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object Point to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{coords}}: expression for coordinates definition, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addPoint(coords)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Point with coordinates \textit{coords} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addPoint(coords, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Point with coordinates \textit{coords} is created in Geom. The name of new object is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addPoint}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addPolyLine: include broken line to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addPolyLine}AToM:+models:+geom:@Geom:addPolyLine         
          \subsection*{addPolyLine: include broken line to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object PolyLine to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: expression for coordinates definition, char [1 x N]/double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addPolyLine(points)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type PolyLine with start defined as first row of \textit{points} and end in last row of \textit{points} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addPolyLine(points, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The name of new object is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addPolyLine}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addPolyLoop: include PolyLoop to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addPolyLoop}AToM:+models:+geom:@Geom:addPolyLoop         
          \subsection*{addPolyLoop: include PolyLoop to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object PolyLoop to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{curveNames}}: names of individual curves to be added, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addPolyLoop(curveNames)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type PolyLoop is created from curves specified by \textit{curveNames} from Geom.\end{par}\begin{Verbatim}
 objName = obj.addPolyLoop(curveNames, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type PolyLoop is created from curves specified by \textit{curveNames} from Geom. The name of new object is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addPolyLoop}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addPolygon: include arbitrary Polygon to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addPolygon}AToM:+models:+geom:@Geom:addPolygon         
          \subsection*{addPolygon: include arbitrary Polygon to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object Polygon to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: expression for coordinates definition, char [1 x N]/double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addPolygon(points)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Polygon with start defined as first row of \textit{points} and end in last row of \textit{points} is created in Geom. If first point and last point are not the same, the first point is copied to the end of points to form closed Polygon.\end{par}\begin{Verbatim}
 objName = obj.addPolygon(points, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The name of new object is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addPolygon}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addRectangle: include Parallelogram of rectangle shape to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addRectangle}AToM:+models:+geom:@Geom:addRectangle         
          \subsection*{addRectangle: include Parallelogram of rectangle shape to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object Parallelogram to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{center}}: rectangle's center point, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{width}}: rectangle's width, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{height}}: rectangle's height, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{normal}}: optional, rectangle's normal spec. (default 'z'), char [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addRectangle(center, width, height)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Parallelogram specified by center point \textit{center}, \textit{width} and \textit{height} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addRectangle(center, width, height, normal)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type Parallelogram specified by center point \textit{center}, \textit{width}, \textit{height} and normal direction \textit{norm} is created in Geom.\end{par}\begin{Verbatim}
 id = obj.addRectangle(center, width, height, normal, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object name is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addRectangle}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{addRectangleFrame: include ParallelogramFrame of rectangle shape to Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:addRectangleFrame}AToM:+models:+geom:@Geom:addRectangleFrame         
          \subsection*{addRectangleFrame: include ParallelogramFrame of rectangle shape to Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method adds a new object ParallelogramFrame to object container of class Geom. It returns objName of the new object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{center}}: rectangle's center point, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{width}}: rectangle's width, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{height}}: rectangle's height, char [1 x N]/double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{normal}}: optional, rectangle's normal spec. (default 'z'), char [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: optional, name of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: name of new GeomObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objName = obj.addRectangleFrame(center, width, height)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type ParallelogramFrame specified by center point \textit{center}, \textit{width} and \textit{height} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addRectangleFrame(center, width, height, normal)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object of type ParallelogramFrame specified by center point \textit{center}, \textit{width}, \textit{height} and normal direction \textit{norm} is created in Geom.\end{par}\begin{Verbatim}
 objName = obj.addRectangleFrame(center, width, height, normal, name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object name is set to \textit{name}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}addRectangleFrame}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{copy: copy object along vector}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:copyObject}AToM:+models:+geom:@Geom:copyObject         
          \subsection*{copy: copy object along vector}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function copies specified object along vector N-times.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objName}}: GeomObject, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: defines where object should be copied, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nNew}}: optional, number of copied objects, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newName}}: optional, names for new objects, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional, type of GeomObject
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.copyObject(objName, vect)
 \end{Verbatim}
 \vspace{2pt}\begin{par}New object is placed along vector \textit{vect} having same properties as origin object \textit{objName}.\end{par}\begin{Verbatim}
 obj.copyObject(objName, vect, nNew)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Several new objects are produced based on definition of \textit{objName}. Number of objects is defined by \textit{nNew}. The distance between two neighbours is defined by euclidean distance of vector \textit{vect}.\end{par}\begin{Verbatim}
 obj.copyObject(objName, vect, nNew, newName)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Produced objects ara named according to char specified in \textit{newName} numbered from 1.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}copyObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{deletObject: delete object from Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:deleteObject}AToM:+models:+geom:@Geom:deleteObject         
          \subsection*{deletObject: delete object from Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method removes an object specified by its name name from Geom \textit{obj}.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional type of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isDeleted}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \vspace{2pt}\begin{par}The object specified by \textit{name} is removed from Geom object \textit{obj}. If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: 'Point, 'Line', 'EllipseArc', 'EquationCurve', 'ParallelogramFrame', 'PolyLine', 'PolyCurve', 'Parallelogram', 'Ellipse', 'PolyLoop', 'Polygon', 'Curve', 'Shape'.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}deleteObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{moveCommandObject: move command to new position in history of object}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:moveCommandObject}AToM:+models:+geom:@Geom:moveCommandObject         
          \subsection*{moveCommandObject: move command to new position in history of object}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method removes a command from history of object's transformations.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{oldNum}}: id of command to be moved, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNum}}: new position of comand in History, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional type of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isMoved}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 oldNum = obj.removeCommandObject(name, oldNum, newNum, type)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The command specified by command number \textit{oldNum} of object specified by \textit{name} is moved in object's history to new position specified by \textit{newNum} \}if the object is found in Geom object \textit{obj}).After the command is removed, the object history is recomputed. If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: Point, Line, EllipseArc, EquationCurve, ParallelogramFrame, PolyCurve, Parallelogram, Ellipse, PolyLoop, Curve, Shape.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}moveCommandObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{reconstructObject: reconstruct object from Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:reconstructObject}AToM:+models:+geom:@Geom:reconstructObject         
          \subsection*{reconstructObject: reconstruct object from Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method reinitiates an object specified by its \textit{name} saved in Geom. The definig properties of the object are set to initiate expresssion value or to new values.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{varargin}}:
           type: optional, type of object, char [1 x N]
           property-value pairs, with new values for defining prop. [1 x 2N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isModified}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 isModified = obj.reconstructObject(name)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object specified by \textit{name} is reconstructed (if found in Geom object \textit{obj}). The objects defining properties are reconstructed to initial expression.\end{par}\begin{Verbatim}
 isModified = obj.reconstructObject(name, type)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object specified by \textit{name} is reconstructed (if found in Geom object \textit{obj}). If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: 'Point', 'Line', 'EllipseArc', 'EquationCurve', 'ParallelogramFrame', 'PolyCurve', 'Parallelogram', 'Ellipse', 'PolyLoop', 'Curve', 'Shape'. The objects defining properties are reconstructed to initial expression.\end{par}\begin{Verbatim}
 isModified = obj.reconstructObject(name, type, varargin)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The objects defining properties are to values defined by 'property'-'value' pairs in \textit{varargin}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}reconstructObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{redrawObject: change number of drawPoints for GeomObjects}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:redrawObject}AToM:+models:+geom:@Geom:redrawObject         
          \subsection*{redrawObject: change number of drawPoints for GeomObjects}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Number of drawPoints of GeomObjects is changed by user.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: names of objects to be modified, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nPoints}}: number of points to be used for visualization, double [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional, types of Geom Object, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.redrawObject(names, nPoints)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The objects of Geom (\textit{obj}) specified in \textit{namse} are changed. Number of drawPoints is set according to \textit{nPoints}.\end{par}\begin{Verbatim}
 obj.redrawObject(names, nPoints, types)
 \end{Verbatim}
 \vspace{2pt}\begin{par}If \textit{types} is specified, the search within Geom is performed faster.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}redrawObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{removeCommandObject: remove command from history of object}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:removeCommandObject}AToM:+models:+geom:@Geom:removeCommandObject         
          \subsection*{removeCommandObject: remove command from history of object}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method removes a command from history of object's transformations.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{cmdNum}}: id of command to be removed, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional type of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isRemoved}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 isRemoved = obj.removeCommandObject(name, cmdNum,  type)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The command specified by command number \textit{cmdNum} of object specified by \textit{name} is removed from object's history if the object is found in Geom object \textit{obj}. After the command is removed, the object history is recomputed. If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: 'Point', 'Line', 'EllipseArc', 'EquationCurve', 'ParallelogramFrame', 'PolyLine', 'PolyCurve', 'Parallelogram', 'Ellipse', 'PolyLoop', 'Polygon', 'Curve', 'Shape'.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}removeCommandObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{renameObject: rename object in Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:renameObject}AToM:+models:+geom:@Geom:renameObject         
          \subsection*{renameObject: rename object in Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method renames an object specified by its name \textit{oldName} from Geom \textit{obj}.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{oldNname}}: current object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNname}}: new name specified by user, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional type of object, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isRenamed}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 isRenamed = renameObject(obj, oldName, newName, type)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object specified by \textit{oldName} is removed from Geom object \textit{obj}. If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: 'Point', 'Line', 'EllipseArc', 'EquationCurve', 'ParallelogramFrame', 'PolyLine', 'PolyCurve', 'Parallelogram', 'Ellipse', 'PolyLoop', 'Polygon', 'Curve', 'Shape'. The object is now named using name specified by user \textit{newName}. If \textit{newName} is allready used in Geom, user is asked to set different name.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}renameObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{rotateObject: rotate object from Geom}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:rotateObject}AToM:+models:+geom:@Geom:rotateObject         
          \subsection*{rotateObject: rotate object from Geom}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method rotates an object specified by its name saved in Geom.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: rotation axis, double [1/2 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: rotation angle, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional type of object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{callerName}}: optional, caller name to control notifications, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isModified}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 isModified = obj.rotateObject(name, vect, angle, type, callerName)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object specified by \textit{name} is rotated (if found in Geom object \textit{obj}). If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: 'Point', 'Line', 'EllipseArc', 'EquationCurve', 'ParallelogramFrame', 'PolyLine' 'PolyCurve', 'Parallelogram', 'Ellipse', 'PolyLoop', 'Polygon', 'Curve', 'Shape'. The object is rotated around vector specified by \textit{vect} around angle determined by \textit{angle}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}rotateObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{rotateXObject: rotate object from Geom around X axis}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:rotateXObject}AToM:+models:+geom:@Geom:rotateXObject         
          \subsection*{rotateXObject: rotate object from Geom around X axis}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method rotates an object specified by its name saved in Geom.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: rotation angle, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional type of object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{callerName}}: optional, caller name to control notifications, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isModified}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 isModified = obj.rotateXObject(name, angle, type, callerName)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object specified by \textit{name} is rotated (if found in Geom object \textit{obj}). If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: 'Point', 'Line', 'EllipseArc', 'EquationCurve', 'ParallelogramFrame', 'PolyLine' 'PolyCurve', 'Parallelogram', 'Ellipse', 'PolyLoop', 'Polygon', 'Curve', 'Shape'. The object is rotated around X axis [1, 0, 0] around angle determined by \textit{angle}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}rotateXObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{rotateYObject: rotate object from Geom around Y axis}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:rotateYObject}AToM:+models:+geom:@Geom:rotateYObject         
          \subsection*{rotateYObject: rotate object from Geom around Y axis}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method rotates an object specified by its name saved in Geom.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: rotation angle, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional type of object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{callerName}}: optional, caller name to control notifications, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isModified}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 isModified = obj.rotateYObject(name, angle, type, callerName)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object specified by \textit{name} is rotated (if found in Geom object \textit{obj}). If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: 'Point', 'Line', 'EllipseArc', 'EquationCurve', 'ParallelogramFrame', 'PolyLine' 'PolyCurve', 'Parallelogram', 'Ellipse', 'PolyLoop', 'Polygon', 'Curve', 'Shape'. The object is rotated around Y axis [0, 1, 0] around angle determined by \textit{angle}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}rotateYObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{rotateZObject: rotate object from Geom around Z axis}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:rotateZObject}AToM:+models:+geom:@Geom:rotateZObject         
          \subsection*{rotateZObject: rotate object from Geom around Z axis}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method rotates an object specified by its name saved in Geom.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: rotation angle, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional type of object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{callerName}}: optional, caller name to control notifications, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isModified}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 isModified = obj.rotateZObject(name, angle, type, callerName)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object specified by \textit{name} is rotated (if found in Geom object \textit{obj}). If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: 'Point', 'Line', 'EllipseArc', 'EquationCurve', 'ParallelogramFrame', 'PolyLine' 'PolyCurve', 'Parallelogram', 'Ellipse', 'PolyLoop', 'Polygon', 'Curve', 'Shape'. The object is rotated around Z axis [0, 0, 1] around angle determined by \textit{angle}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}rotateZObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{scaleObject: scale object from Geom according to vector}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:scaleObject}AToM:+models:+geom:@Geom:scaleObject         
          \subsection*{scaleObject: scale object from Geom according to vector}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method scales an object specified by its name saved in Geom.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: scaling vector, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional type of object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{callerName}}: optional, caller name to control notifications, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isModified}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 isModified = obj.scaleObject(name, vect, type, callerName)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object specified by \textit{name} is scaled (if found in Geom object \textit{obj}). If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: 'Point', 'Line', 'EllipseArc', 'EquationCurve', 'ParallelogramFrame', 'PolyLine' 'PolyCurve', 'Parallelogram', 'Ellipse', 'PolyLoop', 'Polygon', 'Curve', 'Shape'. The object is scaled according to vector specified by \textit{vect}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}scaleObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{translateObject: translate object from Geom according to vector}
          \vspace{1em}
          \label{AToM:+models:+geom:@Geom:translateObject}AToM:+models:+geom:@Geom:translateObject         
          \subsection*{translateObject: translate object from Geom according to vector}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method translates an object specified by its name saved in Geom.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Geom object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: translation vector, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: optional type of object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{callerName}}: optional, caller name to control notifications, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isModified}}: logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 isModified = obj.translateObject(name, angle, type, callerName)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The object specified by \textit{name} is translated (if found in Geom object \textit{obj}). If \textit{type} of object is set, the search is performed faster just within objects of specified type. Possible types are objects of class GeomObjectType: 'Point', 'Line', 'EllipseArc', 'EquationCurve', 'ParallelogramFrame', 'PolyLine' 'PolyCurve', 'Parallelogram', 'Ellipse', 'PolyLoop', 'Polygon', 'Curve', 'Shape'. 'Shape'. The object is translated according to vector specified by \textit{vect}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@Geom\ensuremath{\backslash}translateObject}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{section}{Class +models/+geom/@GeomObject}\vspace{1em}\section*{Class +models/+geom/@GeomObject}
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{areLinesInObject: determine if lines lie inside of an object}
          \vspace{1em}
          \label{AToM:+models:+geom:@GeomObject:areLinesInObject2}AToM:+models:+geom:@GeomObject:areLinesInObject2         
          \subsection*{areLinesInObject: determine if lines lie inside of an object}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method determines if 3D lines lie inside or outside of specified object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object if interest, GeomObject [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{lines}}: 3D lines, struct [1 x nLines]
        .startPoint: start points, double [nLines x 3]
        .endPoint: end point, double [nLines x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isDivided}}: default false, are Segments of obj divided, logical [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{areIn}}: are lines inside object, logical [nP x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{incStruct}}: struct [1 x n]
    .segmentation Parts #, double [1 x nSPIN]
  \textbf{  .curveNums}: seg. curves \# in corresponding segPartNum, double [1 x nSPIN]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [areIn, incStruct] = obj.areLinesInObject(lines)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Method areLinesInObject determines if lines specified by a struct \textit{lines} lie totaly inside or outside the GeomObject \textit{obj}. The line is defined by a struct with properties: lines.startPoint and .endPoint.\end{par}\begin{Verbatim}
 [areIn, incStruct] = obj.areLinesInObject(lines, isDivided)
 \end{Verbatim}
 \vspace{2pt}\begin{par}If \textit{isDivided} set to true, the object contour segments are divided, if line's end point is on it. If \textit{isDivided} set to false, the contour is noy changed.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@GeomObject\ensuremath{\backslash}areLinesInObject2}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{arePointsInObject: determine if points lie inside of an object}
          \vspace{1em}
          \label{AToM:+models:+geom:@GeomObject:arePointsInObject}AToM:+models:+geom:@GeomObject:arePointsInObject         
          \subsection*{arePointsInObject: determine if points lie inside of an object}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method determines if 3D points lie inside or outside of specified object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object if interest, GeomObject [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: 3D points, double [nP x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{parts}}: optional, part \# that should be checked, double [n x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{areIn}}: are points inside object, logical [nP x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{partNums}}: part \# where both IN, cell [1 x nLines], double [nParts x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 areIn = obj.arePointsInObject(points)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Method arePointsInObject determines if 3D \textit{points} lie inside GeomObject \textit{obj} or not.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@GeomObject\ensuremath{\backslash}arePointsInObject}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getLocalCoordinateSystem: get objects local coordinate system}
          \vspace{1em}
          \label{AToM:+models:+geom:@GeomObject:getLocalCoordinateSystem}AToM:+models:+geom:@GeomObject:getLocalCoordinateSystem         
          \subsection*{getLocalCoordinateSystem: get objects local coordinate system}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method determines local coordinate system of specified object.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object if interest, GeomObject [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{origin}}: coordinate system origin if interest, double [nParts x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{localX}}: X axis direction, double [nParts x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{localX}}: Y axis direction, double [nParts x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{localX}}: Z axis direction, double [nParts x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [origin, localX, localY, localZ] = obj.getLocalCoordinateSystem
 \end{Verbatim}
 \vspace{2pt}\begin{par}Method getLocalCoordinateSystem computes one point (\textit{origin}) and thre vectors (\textit{localX}, \textit{localY}, \textit{localZ}) that determines local coordinate system of specified object \textit{obj}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@GeomObject\ensuremath{\backslash}getLocalCoordinateSystem}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getSymmetrySegmentation: get segmentation when symmetries applied}
          \vspace{1em}
          \label{AToM:+models:+geom:@GeomObject:getSymmetrySegmentation}AToM:+models:+geom:@GeomObject:getSymmetrySegmentation         
          \subsection*{getSymmetrySegmentation: get segmentation when symmetries applied}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method gives back segmentation\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of interest, GeomObject [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{symmTypes}}: types of symmetry ('xy', 'xz', 'yz'), cell [1 x nSymm]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{symmSeg}}: segmentation (viz Segmentation doc) of part, Segmentation [1 x 1]
  onSymmetry, is some segPart on Symmetry Plane, cell\{1, nSegParts\} of chars
  intersectLines, iintersetLine segments, IntersectLine [1, nISL]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [symmSeg, onSymmetry, intersectLine] = getSymmetrySegmentation( ...
 obj, symmTypes)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Method getSymmetrySegmentation computes for segmentation of part of symmetry GeomObject \textit{obj}. The part of segmentation is stored in \_symmSeg, which is an object of class Segmentation.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+geom\ensuremath{\backslash}@GeomObject\ensuremath{\backslash}getSymmetrySegmentation}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+mesh}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+mesh}}~}
\fancyhead[RO,RE]{+models/+mesh}\newpage
\cleardoublepage\phantomsection\addcontentsline{toc}{section}{Class +models/+mesh/@Mesh}\vspace{1em}\section*{Class +models/+mesh/@Mesh}
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{convertToImportedMesh: convers geometry to imported mesh}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:convertToImportedMesh}AToM:+models:+mesh:@Mesh:convertToImportedMesh         
          \subsection*{convertToImportedMesh: convers geometry to imported mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Converts mesh from atom geometry to imported mesh.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Mesh object
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: object name, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.convertToImportedMesh();
 obj.convertToImportedMesh(name);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}convertToImportedMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{deleteEdges1D: deletes 1D edges given by edge indices}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:deleteEdges1D}AToM:+models:+mesh:@Mesh:deleteEdges1D         
          \subsection*{deleteEdges1D: deletes 1D edges given by edge indices}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function deletes 1D edges given by edge indices.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Mesh object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edgesToDelete}}: list of 1D edges to remove, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.deleteEdges1D(edgesToDelete);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}deleteEdges1D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{deleteMesh: deletes selected mesh object}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:deleteMesh}AToM:+models:+mesh:@Mesh:deleteMesh         
          \subsection*{deleteMesh: deletes selected mesh object}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Takes mesh object name as input. When an object with a given name is found,
 it's directly deleted if mesh was imported, otherwise user is prompted that
 object was created from AToM geometry.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: Mesh object, Mesh [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of Mesh object to delete, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.deleteMesh(name);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}deleteMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{deleteNodes: deletes nodes of specific meshObject}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:deleteNodes}AToM:+models:+mesh:@Mesh:deleteNodes         
          \subsection*{deleteNodes: deletes nodes of specific meshObject}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function deletes nodes of specific object.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Mesh object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: list of nodes to remove, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.deleteNodes(nodesToDelete);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}deleteNodes}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{deleteTriangles: deletes triangles of specific meshObject}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:deleteTriangles}AToM:+models:+mesh:@Mesh:deleteTriangles         
          \subsection*{deleteTriangles: deletes triangles of specific meshObject}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function deletes triangles of specific object.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Mesh object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{trianglesToDelete}}: list of triangles to remove, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.deleteTriangles(trianglesToDelete);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}deleteTriangles}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{exportMesh: Exports mesh in specified format}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:exportMesh}AToM:+models:+mesh:@Mesh:exportMesh         
          \subsection*{exportMesh: Exports mesh in specified format}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{filePath}}: path to output directory, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of the export file, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}: type of exported format, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.exportMesh(type, name, filePath);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}exportMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getBoundaryMesh: create boundary mesh of 2D mesh objects}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:getBoundaryMesh}AToM:+models:+mesh:@Mesh:getBoundaryMesh         
          \subsection*{getBoundaryMesh: create boundary mesh of 2D mesh objects}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function returns boundary of 2D mesh objects.
 \end{Verbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.getBoundaryMesh();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}getBoundaryMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getCircumsphere: computes mesh circumsphere}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:getCircumsphere}AToM:+models:+mesh:@Mesh:getCircumsphere         
          \subsection*{getCircumsphere: computes mesh circumsphere}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 A circumsphere is computed for the whole mesh and optionaly for each object.
 If eachObject is true, first line is circumsphere of each object and next
 lines are circumsphere of each Mesh Object.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{coordinates}}:
    -radius: radius of a circumsphere, double [N x 1]
    -center: center of a circumsphere, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [coordinates] = obj.getCircumsphere();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}getCircumsphere}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getEdges: get 1D and 2D mesh edges}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:getEdges}AToM:+models:+mesh:@Mesh:getEdges         
          \subsection*{getEdges: get 1D and 2D mesh edges}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges1D}}: 1D element edges, double [N x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges2D}}: 2D element edges, double [N x 2]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [edges1D, edges2D] = obj.getEdges();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}getEdges}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getMesh: loads all curves from geom a generates 1D mesh}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:getMesh}AToM:+models:+mesh:@Mesh:getMesh         
          \subsection*{getMesh: loads all curves from geom a generates 1D mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function calls all specific functions to load geometry and generate 1D
 and 2D mesh.
 \end{Verbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.getMesh();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}getMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getMeshData1D: computes information necessary for 1D mesh solvers}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:getMeshData1D}AToM:+models:+mesh:@Mesh:getMeshData1D         
          \subsection*{getMeshData1D: computes information necessary for 1D mesh solvers}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function loads data from mesh and outputs struct with data necessary
 for 1D mesh solvers.
 \end{Verbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{meshData}}: structure with following items
               -nodes, triangulation nodes, double [N x 3]
               -edges, triangulation edges, double [N x 2]
               -edgeLengths, center point of each edge, double [N x 3]
               -edgeCentroids, length of each edge, double [N x 1]
               -nNodes, number of nodes, double [1 x 1]
               -nEdges, number of edges, double [1 x 1]
               -nNodesBasic, number of nodes before symmetry, double [1 x 1]
               -nEdgesBasic, number of edges before symmetry, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.getMeshData1D();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}getMeshData1D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getMeshData2D: computes information necessary for MoM computations}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:getMeshData2D}AToM:+models:+mesh:@Mesh:getMeshData2D         
          \subsection*{getMeshData2D: computes information necessary for MoM computations}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function loads data from mesh and outputs struct with data necessary
 for MoM
 \end{Verbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{meshData}}: structure with following items
               -nodes, triangulation nodes, double [N x 3]
               -connectivityList, triangulation connectivity list, double [N x 3]
               -edges, triangulation edges, double [N x 2]
               -triangleEdgeCenters, center point of each edge, double [N x 3]
               -triangleEdgeLengths, length of each edge, double [N x 1]
               -triangleAreas, area of each triangle, double [N x 1]
               -triangleCentroids, center points of each triangle, double [N x 3]
               -triangleEdges, indices to edges, double [N x 3]
               -nNodes, number of nodes, double [1 x 1]
               -nEdges, number of edges, double [1 x 1]
               -nTriangles, number of triangles [1 x 1]
               -normDistanceA, radius of circumsphere, double [1 x 1]
               -nNodesBasic, number of nodes before symmetry, double [1 x 1]
               -nEdgesBasic, number of edges before symmetry, double [1 x 1]
               -nTrianglesBasic, number of triangles
                before symmetry, double [1 x 1]
               -edgeOrigins, edges origins before symmetry, double [N x 1]
               -triangleOrigins, triangles origins before symmetry, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.getMeshData2D();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}getMeshData2D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getMeshData3D: computes information necessary for MoM3D computations}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:getMeshData3D}AToM:+models:+mesh:@Mesh:getMeshData3D         
          \subsection*{getMeshData3D: computes information necessary for MoM3D computations}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function loads data from mesh and outputs struct with data necessary
 for MoM3D
 \end{Verbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{meshData}}: structure with following items
               -nodes, tetrahedrization nodes, double [N x 3]
               -connectivityList, tetrahedrization connectivity list, double [N x 4]
               -triangleAreas, area of each triangle, double [N x 1]
               -triangleCentroids, center points of each triangle, double [N x 3]
               -triangleNormals, normals of each triangle, double [N x 3]
               -tetrahedronCentroids, centroid of each tetrahedron, double [N x 3]
               -tetrahedronVolume, volume of each tetrahedron, double [N x 1]
               -tetrahedronTriangles, triangles (facets) of each tetrahedron, double [N x 4]
               -tetrahedronNormalSigns, normals' signs of each triangle, double [N x 4]
               -tetrahedronRegions, material regions of tetrahedrons, double [N x 1]
               -nRegions, number of material regions of tetrahedrons, double [1 x 1]
               -nTetra, number of tetrahedrons, double [1 x 1]
               -nTria, number of triangles, double [1 x 1]
               -circumRadius, radius of circumsphere, double [1 x 1]
               -normDistance, normalization of circumRadius and nodes, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [meshData] = obj.getMeshData3D();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}getMeshData3D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getMeshStatistics: computes statistics for the Mesh and each MeshObject}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:getMeshStatistics}AToM:+models:+mesh:@Mesh:getMeshStatistics         
          \subsection*{getMeshStatistics: computes statistics for the Mesh and each MeshObject}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function loads data from Mesh and Mesh Objects and outputs number
 of triangle, number of nodes, average triangle quality and minimal
 triangle quality, for Mesh and each MeshObject separately.
 \end{Verbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{meshStatistics}}: structure with following items
                   -numNodes, number of triangulation nodes, double [1 x 3]
                   -numTriangles, number of triangles in
                    the triangulation, double [1 x 3]
                   -minQuality, minimal triangle quality, double [1 x 1]
                   -avgQuality, average triangle quality, double [1 x 1]
                   -objects, above mentioned statistics for each
                    mesh object separately [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.getMeshStatistics();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}getMeshStatistics}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{import1DMesh: Imports mesh node coordinates and connectivity}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:import1DMesh}AToM:+models:+mesh:@Mesh:import1DMesh         
          \subsection*{import1DMesh: Imports mesh node coordinates and connectivity}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: node coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: mesh connectivity, double [N x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of created MeshObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.import1DMesh(nodes, connectivityList, name);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}import1DMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{import2DMesh: Imports mesh node coordinates and connectivity}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:import2DMesh}AToM:+models:+mesh:@Mesh:import2DMesh         
          \subsection*{import2DMesh: Imports mesh node coordinates and connectivity}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: node coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: mesh connectivity, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of created MeshObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.import2DMesh(nodes, connectivityList, name);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}import2DMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{import3DMesh: Imports mesh node coordinates and connectivity}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:import3DMesh}AToM:+models:+mesh:@Mesh:import3DMesh         
          \subsection*{import3DMesh: Imports mesh node coordinates and connectivity}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: node coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: mesh connectivity, double [N x 4]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of created MeshObject, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.import3DMesh(nodes, connectivityList, name);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}import3DMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{importMesh: Imports mesh from specific format}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:importMesh}AToM:+models:+mesh:@Mesh:importMesh         
          \subsection*{importMesh: Imports mesh from specific format}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 SUPPORTED FORMATS
  *.mphtxt
  *.nas - NASTRAN in high-precision data format
  *.geo
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Mesh object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{fileName}}: name of imported file, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: imported mesh name, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.importMesh(fileName);
 obj.importMesh(fileName, name);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}importMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{meshToPolygon: creates AToM geometry polygon from a MeshObject}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:meshToPolygon}AToM:+models:+mesh:@Mesh:meshToPolygon         
          \subsection*{meshToPolygon: creates AToM geometry polygon from a MeshObject}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Mesh is converted into polygon and a new Geom object is created. This
 function supports only conversion of planar meshes of arbitrary shapes,
 with arbitrary number of holes.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: Mesh object, Mesh [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of Mesh object to delete, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.meshToPolygon(name);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}meshToPolygon}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{mirrorImportedMesh: mirror mesh}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:mirrorImportedMesh}AToM:+models:+mesh:@Mesh:mirrorImportedMesh         
          \subsection*{mirrorImportedMesh: mirror mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Mirrors mesh according to a mirror plane given by its normal.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Mesh object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: imported mesh object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{normal}}: mirror plane normal, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{numCopies}}: number of copies, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{origin}}: point on the mirror plane, double [1 x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.mirrorImportedMesh(name, normal);
 obj.mirrorImportedMesh(name, normal, numCopies);
 obj.mirrorImportedMesh(name, normal, numCopies, origin);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}mirrorImportedMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotMesh: plots 2D mesh}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:plotMesh}AToM:+models:+mesh:@Mesh:plotMesh         
          \subsection*{plotMesh: plots 2D mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  TODO options
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.plotMesh();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}plotMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotMeshBoundary:: plots boudary edges and nodes}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:plotMeshBoundary}AToM:+models:+mesh:@Mesh:plotMeshBoundary         
          \subsection*{plotMeshBoundary:: plots boudary edges and nodes}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Plots boudary edges and nodes of triangulation given by
 nodes and connectivityList
 \end{Verbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.plotMeshBoundary();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}plotMeshBoundary}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotMeshCircumsphere:: plots mesh and its circumpshere}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:plotMeshCircumsphere}AToM:+models:+mesh:@Mesh:plotMeshCircumsphere         
          \subsection*{plotMeshCircumsphere:: plots mesh and its circumpshere}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Plots circumsphere of triangulation given by nodes and connectivityList
 \end{Verbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.plotMeshCircumsphere();
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}plotMeshCircumsphere}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{renameImportedMesh: renames imported mesh}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:renameImportedMesh}AToM:+models:+mesh:@Mesh:renameImportedMesh         
          \subsection*{renameImportedMesh: renames imported mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Renames only imported meshes. Meshes created from AToM geometry share
 names with Geom objects.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Mesh object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{currentName}}: object to be removed, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newName}}: new mesh object name, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.renameImportedMesh(currentName, newName);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}renameImportedMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{rotateImportedMesh: scales imported mesh}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:rotateImportedMesh}AToM:+models:+mesh:@Mesh:rotateImportedMesh         
          \subsection*{rotateImportedMesh: scales imported mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Rotates imported mesh by scaleVector.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Mesh object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: imported mesh object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{rotateAngles}}: rotate angles, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{numCopies}}: number of copies, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{origin}}: point on the mirror plane, double [1 x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.rotateImportedMesh(name, rotateAngles);
 obj.rotateImportedMesh(name, rotateAngles, numCopies);
 obj.rotateImportedMesh(name, rotateAngles, numCopies, origin);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}rotateImportedMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{scaleImportedMesh: scales imported mesh}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:scaleImportedMesh}AToM:+models:+mesh:@Mesh:scaleImportedMesh         
          \subsection*{scaleImportedMesh: scales imported mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Scales imported mesh by scaleVector.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Mesh object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: imported mesh object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{scaleVector}}: scale vector, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{numCopies}}: number of copies, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{origin}}: point on the mirror plane, double [1 x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.scaleImportedMesh(name, scaleVector);
 obj.scaleImportedMesh(name, scaleVector, numCopies);
 obj.scaleImportedMesh(name, scaleVector, numCopies, origin);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}scaleImportedMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setElementSizeFromFrequency: set property lengthFromFrequency of object which is specified by its name}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:setElementSizeFromFrequency}AToM:+models:+mesh:@Mesh:setElementSizeFromFrequency         
          \subsection*{setElementSizeFromFrequency: set property lengthFromFrequency of object which is specified by its name}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function finds object specified by its name and
 changes its lengthFromFrequency
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of the object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{value}}: new value for lengthFromFrequency, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.setElementSizeFromFrequency(name, value);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}setElementSizeFromFrequency}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setGlobalDensityFunction: sets property densityFunction of object which is specified by name}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:setGlobalDensityFunction}AToM:+models:+mesh:@Mesh:setGlobalDensityFunction         
          \subsection*{setGlobalDensityFunction: sets property densityFunction of object which is specified by name}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function changes global densityFunction.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{func}}: function handle
 \end{IOVerbatim}
 \begin{Verbatim}
 TODO: description of allowed function
 \end{Verbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.setGlobalDensityFunction(functionHandle);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}setGlobalDensityFunction}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setGlobalMeshDensity: set property meshSize to all objects based on frequency}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:setGlobalMeshDensity}AToM:+models:+mesh:@Mesh:setGlobalMeshDensity         
          \subsection*{setGlobalMeshDensity: set property meshSize to all objects based on frequency}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function finds all objects and changes their meshSize parameter.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{densityOfElements}}: number of elements per wavelength, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.setGlobalMeshDensity(densityOfElements);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}setGlobalMeshDensity}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setLocalDensityFunction: sets property densityFunction of object which is specified by name}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:setLocalDensityFunction}AToM:+models:+mesh:@Mesh:setLocalDensityFunction         
          \subsection*{setLocalDensityFunction: sets property densityFunction of object which is specified by name}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function finds object specified by name and changes its
 densityFunction.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of the object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{func}}: function handle
 \end{IOVerbatim}
 \begin{Verbatim}
 TODO: description of allowed function
 \end{Verbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.setLocalDensityFunction(name, functionHandle);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}setLocalDensityFunction}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setLocalMeshDensity: set property meshSize of object which is specified by its name}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:setLocalMeshDensity}AToM:+models:+mesh:@Mesh:setLocalMeshDensity         
          \subsection*{setLocalMeshDensity: set property meshSize of object which is specified by its name}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function finds object specified by its name and changes its meshSize
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of the object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{meshDensity}}: maximal size of mesh, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.setLocalMeshDensity(name, meshDensity);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}setLocalMeshDensity}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setMaxElement: set property maxElement of object which is specified by name}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:setMaxElement}AToM:+models:+mesh:@Mesh:setMaxElement         
          \subsection*{setMaxElement: set property maxElement of object which is specified by name}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function finds object specified by name and changes its
 maximal element size.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of the object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{size}}: maximal element size, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.setMaxElement(name, size);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}setMaxElement}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setQualityPriority: set property qualityPriority}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:setQualityPriority}AToM:+models:+mesh:@Mesh:setQualityPriority         
          \subsection*{setQualityPriority: set property qualityPriority}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function enables quality priority settings for mesh. This is rather
 experimental feature and may help in cases when a standard mesh has too many
 triangles.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{value}}: new value for flag qualityPriority, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.setQualityPriority(value);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}setQualityPriority}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setUniformMeshType: set property uniformMeshType}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:setUniformMeshType}AToM:+models:+mesh:@Mesh:setUniformMeshType         
          \subsection*{setUniformMeshType: set property uniformMeshType}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function sets type of elements used in uniform triangulations
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{elemType}}: 'equilateral' or 'right', char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.setUniformMeshType(elemType);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}setUniformMeshType}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setUseLocalMeshDensity: set property useLocalMeshSize of object which is specified by its name}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:setUseLocalMeshDensity}AToM:+models:+mesh:@Mesh:setUseLocalMeshDensity         
          \subsection*{setUseLocalMeshDensity: set property useLocalMeshSize of object which is specified by its name}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function finds object specified by its name and changes its useLocalMeshSize
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: name of the object, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{value}}: new value for useLocalMeshSize, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.setUseLocalMeshDensity(name, value);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}setUseLocalMeshDensity}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setUseUniformTriangulation: set property isUniform}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:setUseUniformTriangulation}AToM:+models:+mesh:@Mesh:setUseUniformTriangulation         
          \subsection*{setUseUniformTriangulation: set property isUniform}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function finds changes property isUniform
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: object of class Mesh, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{value}}: new value for flag isUniform, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.setUseUniformTriangulation(value);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}setUseUniformTriangulation}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{translateImportedMesh: translates imported mesh}
          \vspace{1em}
          \label{AToM:+models:+mesh:@Mesh:translateImportedMesh}AToM:+models:+mesh:@Mesh:translateImportedMesh         
          \subsection*{translateImportedMesh: translates imported mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Translates imported mesh by translateVector
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{obj}}: Mesh object, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{name}}: imported mesh object name, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{translateVector}}: translate vector, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{numCopies}}: number of copies, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 obj.translateImportedMesh(name, translateVector);
 obj.translateImportedMesh(name, translateVector, numCopies);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+mesh\ensuremath{\backslash}@Mesh\ensuremath{\backslash}translateImportedMesh}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+solvers/+GEP}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+solvers/+GEP}}~}
\fancyhead[RO,RE]{+models/+solvers/+GEP}\newpage
\cleardoublepage\phantomsection\addcontentsline{toc}{section}{Class }\vspace{1em}\section*{Class }
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{assignEigNumbers: assign eigen-numbers to modes track}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:assignEigNumbers}AToM:+models:+solvers:+GEP:assignEigNumbers         
          \subsection*{assignEigNumbers: assign eigen-numbers to modes track}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function assign unsorted eigen-numbers and eigen-vectors to track defined in \textit{modesTrack} and make modes sorted.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: original eigen vectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: original eigen numbers, double [nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{modesTrack}}: modes tracking matrix, double [nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{assignedEigVec}}: assigned eigen vectors, double
                                     [nEdges x maxUsedModeNumber x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{assignedEigNum}}: assigned eigen numbers, double
                                     [maxUsedModeNumber x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [assignedEigVec, assignedEigNum] = ...
    assignEigNumbers(eigVec, eigNum, modesTrack)
 [assignedEigVec, assignedEigNum] = ...
    assignEigNumbers(eigVec, eigNum, modesTrack, gepOptions)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}assignEigNumbers}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeAlpha: compute matrix of alpha coefficients}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeAlpha}AToM:+models:+solvers:+GEP:computeAlpha         
          \subsection*{computeAlpha: compute matrix of alpha coefficients}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Coeffieicnet alpha is computed from modal excitation coefficient.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Vi}}: excitation vectors [nEdges x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigen vectors [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: eigen numbers, double [nModes x nFreq]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{alpha}}: alpha coefiffients [nModes x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 alpha = computeAlpha(Vi, eigVec, eigNum)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeAlpha}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeBeta: compute matrix of beta coefficients}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeBeta}AToM:+models:+solvers:+GEP:computeBeta         
          \subsection*{computeBeta: compute matrix of beta coefficients}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Coefficient betta is computed from alpha coefficient\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Vi}}: excitation vectors, double [nEdges x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigen vectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: eigen numbers, double [nModes x nFreq]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{beta}}: beta coefficients, double [nModes x nModes x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 beta = computeBeta(Vi, eigVec, eigNum)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeBeta}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeCorrTable: compute correlation table between eigen-vectors}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeCorrTable}AToM:+models:+solvers:+GEP:computeCorrTable         
          \subsection*{computeCorrTable: compute correlation table between eigen-vectors}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}General function deciding which core for correlation table computing will be used.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigvectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrInputData}}: data for computing correlation, struct, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrTable}}: correlation table, double [nModes x nModes x nFreq-1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{statusWindow}}: status window for GUI, GEP status window [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrTable}}: correlation coeficients, double [nModes x nModes x nFreq-1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [corrTable, corrInputData] = computeCorrTable(eigVec)
 [corrTable, corrInputData] = computeCorrTable(eigVec, corrInputData)
 [corrTable, corrInputData] = computeCorrTable(eigVec, corrInputData, ...
    gepOptions)
 [corrTable, corrInputData] = computeCorrTable(eigVec, corrInputData, ...
    gepOptions, corrTable,)
 [corrTable, corrInputData] = computeCorrTable(eigVec, corrInputData, ...
    gepOptions, corrTable, statusWindow)
 \end{Verbatim}
 \vspace{2pt}\begin{par}If \textit{corrTable} is given as inputs, new values are computed only on positions, where corrTable(:, :, n) is matrix of NaNs.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeCorrTable}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeCorrTableFF: compute correlation using Far-Field computation}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeCorrTableFF}AToM:+models:+solvers:+GEP:computeCorrTableFF         
          \subsection*{computeCorrTableFF: compute correlation using Far-Field computation}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Far-field for each mode is computed and than 2D correlation coefficient is stored in \textit{corrTable}.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigvectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrInputData}}: data for computing correlation, struct [1 x 1]
  \textbf{  .mesh}: required - mesh structure, struct [1 x 1]
  \textbf{  .basisFcns}: required - basis functions, struct [1 x 1]
  \textbf{  .frequencyList}: required - list of frequencies, double [nFreq x 1]
  \textbf{  .FF}: optional - result struct with modal far-fields, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrTable}}: correlation table, double [nModes x nModes x nFreq-1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{statusWindow}}: status window for GUI, GEP status window [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrTable}}: correlation coeficients, double [nModes x nModes x nFreq-1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrInputData}}: data for computing correlation, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [corrTable, corrInputData] = computeCorrTableFF(eigVec)
 [corrTable, corrInputData] = computeCorrTableFF(eigVec, corrInputData)
 [corrTable, corrInputData] = computeCorrTableFF(eigVec, ...
    corrInputData, gepOptions)
 [corrTable, corrInputData] = computeCorrTableFF(eigVec, ...
    corrInputData, gepOptions, corrTable)
 [corrTable, corrInputData] = computeCorrTableFF(eigVec, ...
    corrInputData, gepOptions, corrTable, statusWindow)
 \end{Verbatim}
 \vspace{2pt}\begin{par}If \textit{corrTable} is given as inputs, new values are computed only on positions, where corrTable(:, :, n) is matrix of NaNs.\end{par}\vspace{2pt}\begin{par}If \textit{corrInputData} contains far-fields, new values are computed only on positions, where farFields(:, :, iFreq, iMode) is matrix of NaNs.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeCorrTableFF}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeCorrTableII: compute correlation between eigen-vectors}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeCorrTableII}AToM:+models:+solvers:+GEP:computeCorrTableII         
          \subsection*{computeCorrTableII: compute correlation between eigen-vectors}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Correaltion coefficient is computed as correlation between two eigen- vectors on next frequency sample.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigvectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrInputData}}: data for computing correlation, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrTable}}: correlation table, double [nModes x nModes x nFreq-1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{statusWindow}}: status window for GUI, GEP status window [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrTable}}: correlation coeficients, double [nModes x nModes x nFreq-1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrInputData}}: data for computing correlation, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [corrTable, corrInputData] = computeCorrTableII(eigVec)
 [corrTable, corrInputData] = computeCorrTableII(eigVec, corrInputData)
 [corrTable, corrInputData] = computeCorrTableII(eigVec, ...
    corrInputData, gepOptions)
 [corrTable, corrInputData] = computeCorrTableII(eigVec, ...
    corrInputData, gepOptions, corrTable)
 [corrTable, corrInputData] = computeCorrTableII(eigVec, ...
    corrInputData, gepOptions, corrTable, statusWindow)
 \end{Verbatim}
 \vspace{2pt}\begin{par}If \textit{corrTable} is given as inputs, new values are computed only on positions, where corrTable(:, :, n) is matrix of NaNs.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeCorrTableII}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeCorrTableIRI: compute correlation table using surface correlation}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeCorrTableIRI}AToM:+models:+solvers:+GEP:computeCorrTableIRI         
          \subsection*{computeCorrTableIRI: compute correlation table using surface correlation}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Surface correaltion is used to compute correlation coefficient\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigvectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrInputData}}: data for computing correlation, struct [1 x 1]
  \textbf{  .R}: required - real part of impedance matrix, double
                                                [nEdges x nEdges x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrTable}}: correlation table, double [nModes x nModes x nFreq-1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{statusWindow}}: status window for GUI, GEP status window [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrTable}}: correlation coeficients, double [nModes x nModes x nFreq-1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrInputData}}: data for computing correlation, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [corrTable, corrInputData] = computeCorrTableIRI(eigVec)
 [corrTable, corrInputData] = computeCorrTableIRI(eigVec, corrInputData)
 [corrTable, corrInputData] = computeCorrTableIRI(eigVec, ...
    corrInputData, gepOptions)
 [corrTable, corrInputData] = computeCorrTableIRI(eigVec, ...
    corrInputData, gepOptions, corrTable)
 [corrTable, corrInputData] = computeCorrTableIRI(eigVec, ...
    corrInputData, gepOptions, corrTable, statusWindow)
 \end{Verbatim}
 \vspace{2pt}\begin{par}If \textit{corrTable} is given as inputs, new values are computed only on positions, where corrTable(:, :, n) is matrix of NaNs.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeCorrTableIRI}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeCorrelation: compute correlation of eig vectors}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeCorrelation}AToM:+models:+solvers:+GEP:computeCorrelation         
          \subsection*{computeCorrelation: compute correlation of eig vectors}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Compute correlation coefficients between given vectors or between vector and matrix.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vec0}}: eigvector of this Mode at this frequency, double [nMode x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{VEC1}}: eigvector of all modes at next frequency, double [nMode x nMode]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrTable}}: table of correlation between modes, double, [1 x nMode]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 corrTable = computeCorrelation(vec0, VEC1)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeCorrelation}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeCorrelation2D: compute correlation of 2D matrixes}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeCorrelation2D}AToM:+models:+solvers:+GEP:computeCorrelation2D         
          \subsection*{computeCorrelation2D: compute correlation of 2D matrixes}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Compute correlation coefficient between two 2D matrices.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{a, b}}: 2D matrices [double]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrCoeff}}: correlation coefficient, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 corrCoeff = computeCorrelation2D(a, b)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeCorrelation2D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeFF: compute modal far-fields}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeFF}AToM:+models:+solvers:+GEP:computeFF         
          \subsection*{computeFF: compute modal far-fields}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Compute modal far-fields.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigvectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequencyList}}: list of frequencies, double [nFreq x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{theta}}: vector of theta points, double [nTheta x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{phi}}: vector of phi points, double [nPhi x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{FF}}: far-field matrice, double [nTheta x nPhi x nFreq x nMode]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{statusWindow}}: status window for GUI, GEP status window [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{FF}}: far-field matrice, double [nTheta x nPhi x nFreq x nMode]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 FF = computeFF(eigVec, mesh, basisFcns, frequencyList, theta, phi)
 FF = computeFF(eigVec, mesh, basisFcns, frequencyList, theta, phi, ...
    gepOptions)
 FF = computeFF(eigVec, mesh, basisFcns, frequencyList, theta, phi, ...
    gepOptions, FF)
 FF = computeFF(eigVec, mesh, basisFcns, frequencyList, theta, phi, ...
    gepOptions, FF, statusWindow)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeFF}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeModalExcitation: compute matrix of modal excitation factors}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeModalExcitation}AToM:+models:+solvers:+GEP:computeModalExcitation         
          \subsection*{computeModalExcitation: compute matrix of modal excitation factors}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Modal Excitation coeeficients are computed as\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Vi}}: excitation vectors [nEdges x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigen vectors [nEdges x nModes x nFreq]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{modalE}}: modal excitation factors [nModes x nModes x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 modalE = computeModalExcitation(Vi, eigVec)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeModalExcitation}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeModalQ: compute modal quality factor Q}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeModalQ}AToM:+models:+solvers:+GEP:computeModalQ         
          \subsection*{computeModalQ: compute modal quality factor Q}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Quality factor Q is computed as\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequencyList}}: list of frequencies [nFreq x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: eigen vectors [nModes x nFreq]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{modalQ}}: modalQ [nModes x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 modalQ = computeModalQ(frequencyList, eigNum)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeModalQ}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeModalSignificance: compute matrix of modal significance factors}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computeModalSignificance}AToM:+models:+solvers:+GEP:computeModalSignificance         
          \subsection*{computeModalSignificance: compute matrix of modal significance factors}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Modal significance factor is computed as abs(1/(1 + 1i*lambda))\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: eigen numbers, double [nModes x nFreq]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{modalS}}: modal significance factors [nModes x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 modalS = computeModalSignificance(eigNum)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computeModalSignificance}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computePiFactor: compute matrix of Pi factors}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:computePiFactor}AToM:+models:+solvers:+GEP:computePiFactor         
          \subsection*{computePiFactor: compute matrix of Pi factors}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Pi factor is computed as max(abs(J\_n)) / (1 + lambda\_n\^{}2)\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{IorJ}}: eigVec or abs(J) [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: eigen numbers, double [nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{PiFac}}: Pi factor [nModes x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 PiFac = computePiFactor(Jabs, eigNum)
 PiFac = computePiFactor(eigVec, eigNum, mesh, basisFcns)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Reference\end{par}\vspace{2pt}\begin{par}J. L. T. Ethier and D. A. Mcnamara, "Modal significance measure in characteristic mode analysis of radiating structures," in Electronics Letters, vol. 46, no. 2, pp. 107-108, January 21 2010.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}computePiFactor}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{connectModes: connect interupted modes}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:connectModes}AToM:+models:+solvers:+GEP:connectModes         
          \subsection*{connectModes: connect interupted modes}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Try to connect modes with previously closed modes.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigvectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{modesTrack}}: modes tracking matrix, double [nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{modesTrack}}: modes tracks with connections, double [nModes x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 modesTrack = connectModes(eigVec, modesTrack)
 modesTrack = connectModes(eigVec, modesTrack, gepOptions)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}connectModes}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{delNegValues: delete negative eigen-values of matrix}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:delNegValues}AToM:+models:+solvers:+GEP:delNegValues         
          \subsection*{delNegValues: delete negative eigen-values of matrix}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Eigen numbers of matrix \textit{A} are computed, negative are discarded and from positive are constrinct new matrix \textit{A}\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{A}}: input matrix, double [N x M]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{A}}: output matrix, double [N x M]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 A = delNegValues(A)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}delNegValues}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{discardModes: discard modes according to specification}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:discardModes}AToM:+models:+solvers:+GEP:discardModes         
          \subsection*{discardModes: discard modes according to specification}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Discard modes according to settings set by user.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigen vectors, double [nEdges x maxUsedModeNumber x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: eigen numbers, double [maxUsedModeNumber x nModes]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{modesTrack}}: modes tracking matrix, double [nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{opt}}: options settings, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigen vector, double [nEdges x maxUsedModeNumber* x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: eigen numbers, double [maxUsedModeNumber* x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{*}}: Number of output modes may be different than number of input modes.
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [eigVec, eigNum] = discardModes(eigVec, eigNum, modesTrack)
 [eigVec, eigNum] = discardModes(eigVec, eigNum, modesTrack, gepOptions)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}discardModes}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{findMaxUsedModeNumber: find max used mode number}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:findMaxUsedModeNumber}AToM:+models:+solvers:+GEP:findMaxUsedModeNumber         
          \subsection*{findMaxUsedModeNumber: find max used mode number}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Find maximal used mode number in \textit{modesTrack} matrix.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{modesTrack}}: modes tracking matrix, double [nModes x nFreq]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{maxUsedModeNumber}}: maximal used mode number, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 maxUsedModeNumber = findMaxUsedModeNumber(modesTrack)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}findMaxUsedModeNumber}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{gep: solve Generalized Eigenvalue Problem}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:gep}AToM:+models:+solvers:+GEP:gep         
          \subsection*{gep: solve Generalized Eigenvalue Problem}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Compute GEP: A eigVec = eigNum B eigVec\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{A}}: input matrix, double [nEdges x nEdges]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{B}}: input matrix, double [nEdges x nEdges]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{N}}: normalized matrix, double [nEdges x nEdges]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
 \end{IOVerbatim}
 \vspace{2pt}\begin{par}if \textit{N} is empty or NaN, \textit{B} is used to normalization\end{par}\subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigen-vectors, double [nEdges x nModes]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: eigen-numbers, double [nModes x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{INI}}: reacted power, double, [nModes x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [eigVec, eigNum, INI] = gep(A, B)
 [eigVec, eigNum, INI] = gep(A, B, N)
 [eigVec, eigNum, INI] = gep(A, B, N, gepOptions)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}gep}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getOption: return vale of option}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:getOption}AToM:+models:+solvers:+GEP:getOption         
          \subsection*{getOption: return vale of option}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Return value of required option from options structure.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{optionsStruct}}: structure with options, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{optionName}}: name of required option, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{value}}: value of required option, any
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 value = getOption(optionsStruct, optionName)
 \end{Verbatim}
 \vspace{2pt}\begin{par}description\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}getOption}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{prepareResultStruct: prepare struct for result}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:prepareResultStruct}AToM:+models:+solvers:+GEP:prepareResultStruct         
          \subsection*{prepareResultStruct: prepare struct for result}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Create structure for result\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{description}}: name of this result, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{dimensions}}: dimensions of this result, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{freqDepDim}}: frequency-dependent dimension, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{units}}: units of this result, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{data}}: data of this result, double [any]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{resultStruct}}: structure of result, struct [1 x 1]
  \textbf{  .description}: description of result, char [1 x N]
  \textbf{  .data}: results data, double [any]
  \textbf{  .size}: size of data, double [1 x N]
  \textbf{  .dimensions}: description of dimensions, char [1 x N]
  \textbf{  .units}: units of data, char, [1 x N]
  \textbf{  .frequencyDependentDimension}: number of frequency-dependent
                                                dimension, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 resultStruct = prepareResultStruct(description, dimensions, ...
    freqDepDim)
 resultStruct = prepareResultStruct(description, dimensions, ...
    freqDepDim, units)
 resultStruct = prepareResultStruct(description, dimensions, ...
    freqDepDim, units, data)
 \end{Verbatim}
 \vspace{2pt}\begin{par}If result does not have frequency-dependent dimension, set \textit{freqDepDim} = 0.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}prepareResultStruct}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{procgep: solve Generalized Eigenvalue Problem with pre-\&post- processing}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:procgep}AToM:+models:+solvers:+GEP:procgep         
          \subsection*{procgep: solve Generalized Eigenvalue Problem with pre-\&post- processing}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Generalized Eigenvalue Problem: A eigVec = eigNum B eigVec\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{A}}: input matrix, double [nEdges x nEdges]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{B}}: input matrix, double [nEdges x nEdges]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{N}}: normalized matrix, double [nEdges x nEdges]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
 \end{IOVerbatim}
 \vspace{2pt}\begin{par}if \textit{N} is empty or NaN, \textit{B} is used to normalization\end{par}\subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigen-vectors, double [nEdges x nModes]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: eigen-numbers, double [nModes x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [eigVec, eigNum, INI] = procgep(A, B)
 [eigVec, eigNum, INI] = procgep(A, B, N)
 [eigVec, eigNum, INI] = procgep(A, B, N, gepOptions)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}procgep}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{scanModesProperties: returns modes properties from given modesTrack}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:scanModesProperties}AToM:+models:+solvers:+GEP:scanModesProperties         
          \subsection*{scanModesProperties: returns modes properties from given modesTrack}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Return informations about modes from \textit{modesTrack} matrix\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{modesTrack}}: modes tracking matrix, double [nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{modesProp}}: output structure, struct [1 x 1]
  \textbf{  .maxUsedModeNumber}: maximal value in modesTrack, double, [1 x 1]
  \textbf{  .start}: indicator where modes start, double [1 x maxUsedModeNumber]
  \textbf{  .end}: indicator where modes end, double [1 x maxUsedModeNumber]
  \textbf{  .length}: length of modes, double [1 x maxUsedModeNumber]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 modesProp = scanModesProperties(modesTrack)
 modesProp = scanModesProperties(modesTrack, gepOptions)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}scanModesProperties}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{solve: run GEP solver}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:solve}AToM:+models:+solvers:+GEP:solve         
          \subsection*{solve: run GEP solver}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Run GEP solver\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{solver}}: GEP solver object, GEP [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequencyList}}: list of frequencies, double [nFreq x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
   solve(objGEP)
   solve(objGEP, frequencyList)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}solve}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{symmetrizeMatrix: make the matrix symmetric}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:symmetrizeMatrix}AToM:+models:+solvers:+GEP:symmetrizeMatrix         
          \subsection*{symmetrizeMatrix: make the matrix symmetric}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Make the matrix symmetric\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{A}}: input matrix, double [N x M]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{symA}}: symmetrized matrix, double [N x M]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 symA = symmetrizeMatrix(A)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}symmetrizeMatrix}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{trackingCM: track modes with respect to corrTable}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:trackingCM}AToM:+models:+solvers:+GEP:trackingCM         
          \subsection*{trackingCM: track modes with respect to corrTable}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Track and sort modes according to correlation coefficients in correlation table.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: unsorted eigen-vectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: unsorted eigen-numbers, double [nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrInputData}}: additional data for correlation comp., struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{gepOptions}}: options settings, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrTable}}: correlationTable, double [nModes x nModes x nFreq-1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{outStruct}}: output structure, struct [1 x 1]
  \textbf{  .modesTrack}: modes track in unsorted values, double, [nModes x nFreq]
  \textbf{  .eigNumSorted}: sorted eigen numbers, double
                                              [maxUsedModeNumber x nFreq]
  \textbf{  .eigVecSorted}: sorted eigen vectors, double
                                     [nEdges x maxUsedModeNumber x nFreq]
  \textbf{  .corrTable}: correlation table, double [nModes x nModes x nFreq-1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrInputData}}: additional data for correlation comp., struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [outStruct, corrInputData] = trackingCM(eigVec, eigNum)
 [outStruct, corrInputData] = trackingCM(eigVec, eigNum, ...
    corrInputData)
 [outStruct, corrInputData] = trackingCM(eigVec, eigNum, ...
    corrInputData, gepOptions)
 [outStruct, corrInputData] = trackingCM(eigVec, eigNum, ...
    corrInputData, gepOptions, corrTable)
 [outStruct, corrInputData] = trackingCM(eigVec, eigNum, ...
    corrInputData, gepOptions, corrTable, statusWindow)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}trackingCM}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+solvers/+GEP/+customFunctions}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+solvers/+GEP/+customFunctions}}~}
\fancyhead[RO,RE]{+models/+solvers/+GEP/+customFunctions}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{postEigSMatrixDecomposition: is used as post-eigs function}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:+customFunctions:postEigSMatrixDecomposition}AToM:+models:+solvers:+GEP:+customFunctions:postEigSMatrixDecomposition         
          \subsection*{postEigSMatrixDecomposition: is used as post-eigs function}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function is called after eig/eigs when S matrix is used for computing characteristic modes and eigen-vectors and eigen-numbers are postprocessed here.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: eigen-vectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: eigen-numbers, double [nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{iFreq}}: number of frequency sample, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objGEP}}: GEP object, GEP [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{dataFromPreProc}}: data prom preprocessing function, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigVec}}: updated eigen-vectors, double [nEdges x nModes x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigNum}}: updated eigen-numbers, double [nModes x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [eigVec, eigNum] = postEigSMatrixDecomposition(eigVec, eigNum, ...
    iFreq, objGEP, dataFromPreproc)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}+customFunctions\ensuremath{\backslash}postEigSMatrixDecomposition}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{preEigSMatrixDecomposition: is used as pre-eigs function}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:+customFunctions:preEigSMatrixDecomposition}AToM:+models:+solvers:+GEP:+customFunctions:preEigSMatrixDecomposition         
          \subsection*{preEigSMatrixDecomposition: is used as pre-eigs function}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function is called before eig/eigs when S matrix is used for computing characteristic modes and input matrices are pre-processed here.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{data}}: input matrices, struct [1 x 1]
  \textbf{  .A}: input matrix, double [nEdges x nEdges]
  \textbf{  .B}: input matrix, double [nEdges x nEdges]
  \textbf{  .N}: normalized matrix, double [nEdges x nEdges]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{iFreq}}: number of frequency sample, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objGEP}}: GEP object, GEP [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{data}}: updated input matrices, struct [1 x 1]
  \textbf{  .A}: input matrix, double [nEdges x nEdges]
  \textbf{  .B}: input matrix, double [nEdges x nEdges]
  \textbf{  .N}: normalized matrix, double [nEdges x nEdges]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{dataForPostproc}}: data prom preprocessing function, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [data, dataForPostproc] = preEigSMatrixDecomposition(data, iFreq, ...
    objGEP)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}+customFunctions\ensuremath{\backslash}preEigSMatrixDecomposition}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{solveSMatrixDecomposition: run solver for SMatrix decomposition}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:+customFunctions:solveSMatrixDecomposition}AToM:+models:+solvers:+GEP:+customFunctions:solveSMatrixDecomposition         
          \subsection*{solveSMatrixDecomposition: run solver for SMatrix decomposition}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function run custom inner solver in GEP when S matrix is used for computing characteristic modes.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objSolver}}: object of inner solver, struct [1 x 1]
  \textbf{  .solver}: reference to MoM2D, solver [1 x 1]
  \textbf{  .S}: alocation for S matrix, double [0 x 0]
  \textbf{  .X}: alocation for X matrix, double [0 x 0]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequencyList}}: list of frequencies, double [nFreq x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{waitBar}}: waitbar in GEP status window, waitbar [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objSolver}}: object of inner solver, struct [1 x 1]
  \textbf{  .solver}: reference to MoM2D, solver [1 x 1]
  \textbf{  .S}: S matrix, double [maxAlpha x nEdges x nFreq]
  \textbf{  .X}: X matrix, double [nEdges x nEdges x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objSolver = solveSMatrixDecomposition(objSolver, frequencyList, waitBar)
 \end{Verbatim}
 \begin{Verbatim}
 Note:  _objSolver_ is in general named as solver, but here it is struct.
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}+customFunctions\ensuremath{\backslash}solveSMatrixDecomposition}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{solverSMatrixDecomposition: create solver for SMatrix decomposition}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:+customFunctions:solverSMatrixDecomposition}AToM:+models:+solvers:+GEP:+customFunctions:solverSMatrixDecomposition         
          \subsection*{solverSMatrixDecomposition: create solver for SMatrix decomposition}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function create solver when S matrix is used for computing characteristic modes.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{objGEP}}: GEP object, GEP [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mySolver}}: structure of my solver, struct [1 x 1]
   .solver: reference to MoM2D, solver [1 x 1]
   .S: alocation for S matrix, double [0 x 0]
   .X: alocation for X matrix, double [0 x 0]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 mySolver = solverSMatrixDecomposition(objGEP)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}+customFunctions\ensuremath{\backslash}solverSMatrixDecomposition}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+solvers/+GEP}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+solvers/+GEP}}~}
\fancyhead[RO,RE]{+models/+solvers/+GEP}\newpage
\cleardoublepage\phantomsection\addcontentsline{toc}{section}{Class +models/+solvers/+GEP/@GEP}\vspace{1em}\section*{Class +models/+solvers/+GEP/@GEP}
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{GEP: creates solver using General Eigenvalue Problem}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:GEP}AToM:+models:+solvers:+GEP:@GEP:GEP         
          \subsection*{GEP: creates solver using General Eigenvalue Problem}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Main class of GEP\end{par}
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 myGEP = models.solvers.GEP()
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}GEP}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{clearInputs: clear inputs}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:clearInputs}AToM:+models:+solvers:+GEP:@GEP:clearInputs         
          \subsection*{clearInputs: clear inputs}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Clear input matrices, frequency list and inner solver object.\end{par}
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.clearInputs()
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}clearInputs}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{clearOutputs: clear outputs}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:clearOutputs}AToM:+models:+solvers:+GEP:@GEP:clearOutputs         
          \subsection*{clearOutputs: clear outputs}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Clear all outputs in results structure.\end{par}
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.clearOutpus()
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}clearOutputs}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{defaultControls: provide struct of control handles for given inner solver}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:defaultControls}AToM:+models:+solvers:+GEP:@GEP:defaultControls         
          \subsection*{defaultControls: provide struct of control handles for given inner solver}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Provide struct of control handles for given inner solver. Fields contains string with handles which are set to corresponding GEP propertis when solver is started.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{innerSolver}}: name of inner solver, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{defControls}}: handles for controlling inner solver, struct [1 x 1]
  \textbf{  .innerSolverHndl}: get object of inner solver, char [1 x N]
  \textbf{  .innerSolverSolve}: solve inner solver, char [1 x N]
  \textbf{  .innerSolverGetA}: get matrix A from inner solver, char [1 x N]
  \textbf{  .innerSolverGetB}: get matrix B from inner solver, char [1 x N]
  \textbf{  .innerSolverGetN}: get matrix N from inner solver, char [1 x N]
  \textbf{  .eigRunPreAndPostprocessing}: run function before and after eig/eigs,
                                                          logical [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigPreprocessing}}: eig/eigs pre-processing, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigPostprocessing}}: eig/eigs post-processing, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 defControls = objGEP.defaultControls(innerSolver)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}defaultControls}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getDefaultProperties: returns structure of default GEP properties}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:getDefaultProperties}AToM:+models:+solvers:+GEP:@GEP:getDefaultProperties         
          \subsection*{getDefaultProperties: returns structure of default GEP properties}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Structure with default values for GEP properties.\end{par}\subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{defaultProperties}}: struture of default properties, struct [1 x 1]
  \textbf{  .propertyName}: contain default value, any
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 defaultProperties = objGEP.getDefaultProperties()
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}getDefaultProperties}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getPropertyList: returns names of properties}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:getPropertyList}AToM:+models:+solvers:+GEP:@GEP:getPropertyList         
          \subsection*{getPropertyList: returns names of properties}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Get names of GEP properties which can be set by method setProperties().\end{par}\subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{defaultProperties}}: struture of default properties, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 defaultProperties = objGEP.getDefaultProperties()
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}getPropertyList}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{resetPropertiesToDefault: reset properties of GEP to default values}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:resetPropertiesToDefault}AToM:+models:+solvers:+GEP:@GEP:resetPropertiesToDefault         
          \subsection*{resetPropertiesToDefault: reset properties of GEP to default values}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Reser properties to default\end{par}
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.resetPropertiesToDefault()
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}resetPropertiesToDefault}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setCorrInputData: set corrInputData as corrInputData to GEP properties}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:setCorrInputData}AToM:+models:+solvers:+GEP:@GEP:setCorrInputData         
          \subsection*{setCorrInputData: set corrInputData as corrInputData to GEP properties}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Store required data for correlation from inner solver.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{corrInputData}}: structure with datas, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.setCorrInputData(corrInputData)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}setCorrInputData}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setFrequencyList: set list of frequencies to GEP properties}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:setFrequencyList}AToM:+models:+solvers:+GEP:@GEP:setFrequencyList         
          \subsection*{setFrequencyList: set list of frequencies to GEP properties}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Set frequency list\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequencyList}}: frequency list, double [nFreq x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.setFrequencyList(frequencyList)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}setFrequencyList}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setMatrices: set all input matrices to GEP properties}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:setMatrices}AToM:+models:+solvers:+GEP:@GEP:setMatrices         
          \subsection*{setMatrices: set all input matrices to GEP properties}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Set all three matrices as input\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{A}}: input matrix, double [nEdges x nEdges x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{B}}: input matrix, double [nEdges x nEdges x nFreq]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{N}}: normalized matrix, double [nEdges x nEdges x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.setMatrices(A, B, N)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}setMatrices}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setMatrix: set data to given input to GEP properties}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:setMatrix}AToM:+models:+solvers:+GEP:@GEP:setMatrix         
          \subsection*{setMatrix: set data to given input to GEP properties}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Set selected matrix\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nameOfMatrix}}: matrix name ('A' or 'B' or 'N'), char [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{matrix}}: input matrix, double [nEdges x nEdges x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.setMatrix(nameOfMatrix, matrix)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}setMatrix}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setMatrixA: set A as matrixA to GEP properties}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:setMatrixA}AToM:+models:+solvers:+GEP:@GEP:setMatrixA         
          \subsection*{setMatrixA: set A as matrixA to GEP properties}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Set matrix A.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{A}}: input matrix, double [nEdges x nEdges x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.setMatrixA(A)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}setMatrixA}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setMatrixB: set B as matrixB to GEP properties}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:setMatrixB}AToM:+models:+solvers:+GEP:@GEP:setMatrixB         
          \subsection*{setMatrixB: set B as matrixB to GEP properties}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Set matrix B.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{B}}: input matrix, double [nEdges x nEdges x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.setMatrixB(B)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}setMatrixB}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{setMatrixN: set N as matrixN to GEP properties}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:setMatrixN}AToM:+models:+solvers:+GEP:@GEP:setMatrixN         
          \subsection*{setMatrixN: set N as matrixN to GEP properties}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Set matrix N.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{N}}: normalized matrix, double [nEdges x nEdges x nFreq]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.setMatrixN(N)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}setMatrixN}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{solve: solve GEP}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:solve}AToM:+models:+solvers:+GEP:@GEP:solve         
          \subsection*{solve: solve GEP}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Run GEP solver\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequencyList}}: list of frequencies, double [nFreq x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.solve()
 objGEP.solve(frequencyList)
 \end{Verbatim}
 \vspace{2pt}\begin{par}If \textit{frequencyList} is set, frequencies in objGEP.frequencyList are ingored.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}solve}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{updateResult: update given result of GEP}
          \vspace{1em}
          \label{AToM:+models:+solvers:+GEP:@GEP:updateResult}AToM:+models:+solvers:+GEP:@GEP:updateResult         
          \subsection*{updateResult: update given result of GEP}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Set new data to given result.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{result}}: result, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newData}}: new data, any
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 objGEP.updateResult(result, newData)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+GEP\ensuremath{\backslash}@GEP\ensuremath{\backslash}updateResult}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+solvers/+MoM2D}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+solvers/+MoM2D}}~}
\fancyhead[RO,RE]{+models/+solvers/+MoM2D}\newpage
\cleardoublepage\phantomsection\addcontentsline{toc}{section}{Class }\vspace{1em}\section*{Class }
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{possibleResultRequests: returns list of output request which can be used}
          \vspace{1em}
          \label{AToM:+models:+solvers:+MoM2D:possibleResultRequests}AToM:+models:+solvers:+MoM2D:possibleResultRequests         
          \subsection*{possibleResultRequests: returns list of output request which can be used}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}List of the result requests is formed as a list of result definitions in namespace "resultDefs".\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}possibleResultRequests}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+solvers/+MoM2D/+computation}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+solvers/+MoM2D/+computation}}~}
\fancyhead[RO,RE]{+models/+solvers/+MoM2D/+computation}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getJInPoints: returns values of current density in general points}
          \vspace{1em}
          \label{AToM:+models:+solvers:+MoM2D:+computation:getJInPoints}AToM:+models:+solvers:+MoM2D:+computation:getJInPoints         
          \subsection*{getJInPoints: returns values of current density in general points}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This method returns values of the current density and its divergence evaluated in general points given by the user or in the triangle centroids. The last output variable \textit{points} contains coordinates of the points for which the values were computed. Procedure: \ensuremath{\tilde{\;}}\ensuremath{\tilde{\;}}\ensuremath{\tilde{\;}}\ensuremath{\tilde{\;}}\ensuremath{\tilde{\;}}\ensuremath{\tilde{\;}}\ensuremath{\tilde{\;}}\ensuremath{\tilde{\;}}\ensuremath{\tilde{\;}}\ensuremath{\tilde{\;}} Get topology 1.) find triangles for points 2.) find basis functions for triangles Solve topology 3.) accumulate basis function contributions to triangles 4.) accumulate triangle contributions to points\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: computational mesh
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: information about basis functions
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{iVec}}: current density coefficients, double [#unknowns x #frequencies]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: Cartesian coordinates of the points, double [\#points x 3]
          This parameter is optional.
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Jx}}: x component of the current density, double [#unknowns x #frequencies]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Jy}}: y component of the current density, double [#unknowns x #frequencies]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Jz}}: z component of the current density, double [#unknowns x #frequencies]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{divJ}}: divergence of the current density, double [#unknowns x #frequencies]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: Cartesian coordinates of the points, double [\#points x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 getJInPoints(obj, jVec, points)
 \end{Verbatim}
 \vspace{2pt}\begin{par}User defines points where the current density will be evaluated.\end{par}\begin{Verbatim}
 getJInPoints(obj, jVec)
 \end{Verbatim}
 \vspace{2pt}\begin{par}The points are not user-defined. Triangle centroids are used instead.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+solvers\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+computation\ensuremath{\backslash}getJInPoints}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+utilities/+geomPublic}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+utilities/+geomPublic}}~}
\fancyhead[RO,RE]{+models/+utilities/+geomPublic}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{arePointsInPolygon: determine if points are in polygon or not}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:arePointsInPolygon}AToM:+models:+utilities:+geomPublic:arePointsInPolygon         
          \subsection*{arePointsInPolygon: determine if points are in polygon or not}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function determines if 2D points are inside or outside of specified 2D polygon.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: set of points, double [nPoints x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{polygon}}: nodes of polygon in CCW order, double [nNodes x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{holeSeg}}: hole indicator (1 solid, >1 hole), double [nNodes x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tol}}: geom precision, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{areIn}}: are points in or not, logical [nPoints x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 areIn = models.utilities.geomPublic.arePointsInPolygon(points, polygon)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function arePointsInPolygon determines if 2D points \textit{points} are inside or outside of a polygon \textit{polygon}. The computation is based on winding number according to \url{http://geomalgorithms.com/a03-_inclusion.html}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}arePointsInPolygon}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{arePointsInSamePlane: determine if points are in same plane}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:arePointsInSamePlane}AToM:+models:+utilities:+geomPublic:arePointsInSamePlane         
          \subsection*{arePointsInSamePlane: determine if points are in same plane}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function determines if a set of 3d points is co-planar / all points lie in teh same plane.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: set of points, double [nPoints x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tol}}: optional, geom precision, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{areInSame}}: are points in same plane, logical [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{areColinear}}: are points in one line, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [areInSame, areColinear] = ...
 models.utilities.geomPublic.arePointsInSamePlane(points, tol)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function arePointsInSamePlane determines if 3D points \textit{points} lie all in the sam plane according to numerical precision \textit{tol}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}arePointsInSamePlane}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{checkSamePoints: determine if points are same according to tolerance}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:checkSamePoints}AToM:+models:+utilities:+geomPublic:checkSamePoints         
          \subsection*{checkSamePoints: determine if points are same according to tolerance}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function determines if points are same (distance lower than tolerance) and replaces points with same entries.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: set of points, double [nPoints x 2/3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tolernace}}: geom precision, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{checkedPoints}}: points rounded to tolerance, doble [nPoints x 2/3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 checkedPoints = models.utilities.geomPublic.checkSamePoints( ...
 points, tolerance)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function checkSamePoints determines if 2D points \textit{points} have smae points, that are closer than tolernace. In that case, points are rplaced bz the first occurance.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}checkSamePoints}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{crossProduct: find cross product between two sets of vectors}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:crossProduct}AToM:+models:+utilities:+geomPublic:crossProduct         
          \subsection*{crossProduct: find cross product between two sets of vectors}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function determines crossproduct of two sets of 3D vectors.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect1}}: set of vectors, double [nV1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect2}}: set of vectors, double [nV2 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mode}}: optional, normalization of cross product vector, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{crossProd}}: cross product, struct [1 x 1]
  \textbf{  .x}: x-coordinates, double [nV1 x nV2]
  \textbf{  .y}: y-coordinates, double [nV1 x nV2]
  \textbf{  .z}: z-coordinates, double [nV1 x nV2]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 crossProd = models.utilities.geomPublic.crossProduct(vect1, vect2)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function crossProduct determines cross product of two sets of 3D vectors determined bz \textit{vect1} and \textit{vect2}.\end{par}\begin{Verbatim}
 crossProd = models.utilities.geomPublic.crossProduct(vect1, vect2, mode)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Mode of output vector specified by user in \textit{mode}. Default mode is 'normalized', other option is 'notModified'.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}crossProduct}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{distanceFromPointsToLines: compute distance from points to lines}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:distanceFromPointsToLines}AToM:+models:+utilities:+geomPublic:distanceFromPointsToLines         
          \subsection*{distanceFromPointsToLines: compute distance from points to lines}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes perpendicular distance between sets of points and lines defined by two points in 3D.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: set of points, double [nPoints x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{lines}}: struct [1 x nLines]
        .startPoint: start points, double [nLines x 3]
        .endPoint: end point, double [nLines x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{distMatrix}}: distance from Points to Lines, double [nPoints x nLines]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{parameters}}: parametric projection of P. to L., double [nPoints x nLines]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [distMatrix, parameters] = models.utilities.geomPublic. ...
 distanceFromPointsToLines(points, lines)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function distanceFromPointsToLines computes pairwise distances between set of points defined in \textit{points} and set of lines defined in struct \textit{lines}. This struct is formed by two points (\textit{lines.startPoint} and \textit{lines.endPoint}).\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}distanceFromPointsToLines}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{distanceFromPointsToPlanes: compute distance from points to planes}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:distanceFromPointsToPlanes}AToM:+models:+utilities:+geomPublic:distanceFromPointsToPlanes         
          \subsection*{distanceFromPointsToPlanes: compute distance from points to planes}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes distance between sets of points and planes defined in 3D.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: set of points, double [nPoints x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{planes}}: struct [1 x nPlanes]
        .normal: normal vector, double [1 x 3]
        .pointIn: point on a plane, double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{distMatrix}}: distance between points, double [nPoints x nPlanes]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 distMatrix = models.utilities.geomPublic. ...
 distanceFromPointsToPlanes(points, planes)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function distanceFromPointsToPlanes computes pairwise distances between set of points defined in \textit{points} and set of planes defined in struct \textit{planes}. This struct is formed by planes normal vector (\textit{planes.normal}) and a point on the plane (\textit{planes.pointIn}).\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}distanceFromPointsToPlanes}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{dotProduct: find dot product between two sets of vectors}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:dotProduct}AToM:+models:+utilities:+geomPublic:dotProduct         
          \subsection*{dotProduct: find dot product between two sets of vectors}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function determines dotproduct of two sets of 3D vectors.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect1}}: set of vectors, double [nV1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect2}}: set of vectors, double [nV2 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mode}}: optional, normalization of dot product vector, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{dotProd}}: dot product, struct [nV1 x nV2]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 dotProd = models.utilities.geomPublic.dotProduct(vect1, vect2)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function dotProduct determines dot product of two sets of 3D vectors determined bz \textit{vect1} and \textit{vect2}.\end{par}\begin{Verbatim}
 dotProd = models.utilities.geomPublic.dotProduct(vect1, vect2, mode)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Mode of output vector specified by user in \textit{mode}. Default mode is 'normalized', other option is 'notModified'.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}dotProduct}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{euclideanDistanceBetweenTwoSets: compute distance between two sets of points}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:euclideanDistanceBetweenTwoSets}AToM:+models:+utilities:+geomPublic:euclideanDistanceBetweenTwoSets         
          \subsection*{euclideanDistanceBetweenTwoSets: compute distance between two sets of points}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes Euclidean distance between two sets of points.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{set1}}: first set of points, double [nPoints x nDims]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{set2}}: second set of points, double [mPoints x nDims]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{distMatrix}}: distance between points, double [nPoints x mPoints]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 distMatrix = models.utilities.geomPublic. ...
 euclideanDistanceBetweenTwoSets(set1, set2)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function euclideanDistanceBetweenTwoSets computes pairwise distances between two sets of points defined in \textit{set1} and \textit{set2}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}euclideanDistanceBetweenTwoSets}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{euclideanDistanceBetweenTwoSetsSqrt: compute distance between sets of points}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:euclideanDistanceBetweenTwoSetsSqrt}AToM:+models:+utilities:+geomPublic:euclideanDistanceBetweenTwoSetsSqrt         
          \subsection*{euclideanDistanceBetweenTwoSetsSqrt: compute distance between sets of points}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes Euclidean distance between two sets of points. It is more robust variant of function: models.utilities.geomPublic.euclideanDistanceBetweenTwoSets\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{set1}}: first set of points, double [nPoints x nDims]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{set2}}: second set of points, double [mPoints x nDims]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tol}}: optional, tolerance before sqrt, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{distMatrix}}: distance between points, double [nPoints x mPoints]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 distMatrix = models.utilities.geomPublic. ...
 euclideanDistanceBetweenTwoSets(set1, set2)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function euclideanDistanceBetweenTwoSets computes pairwise distances between two sets of points defined in \textit{set1} and \textit{set2}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}euclideanDistanceBetweenTwoSetsSqrt}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{findNumberOfOccurances: find number of occurances of element in other vector}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:findNumberOfOccurances}AToM:+models:+utilities:+geomPublic:findNumberOfOccurances         
          \subsection*{findNumberOfOccurances: find number of occurances of element in other vector}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function searches for number of occurances of each element of specified \textit{alphabet} in defined vector with repetitions \textit{vect}.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{alphabet}}: values to be found in vect, double [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: vector of interest, double [1 x nVectSize]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nOccur}}: number of occurances of alphabet elements in vect, double [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 nOccur = models.utilities.geomPublic.findNumberOfOccurances(alphabet, vect)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function findNumberOfOccurances computes how many times elements of \textit{alphabet} occur in vector of interest \textit{vect}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}findNumberOfOccurances}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{: }
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:gen-ifs-fractal}AToM:+models:+utilities:+geomPublic:gen-ifs-fractal         
          \subsection*{: }
 
          \begin{mdframed}
          \vspace{5pt}
          
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}gen\_ifs\_fractal}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{geomUnique: finds unique rows according to relative tolerance}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:geomUnique}AToM:+models:+utilities:+geomPublic:geomUnique         
          \subsection*{geomUnique: finds unique rows according to relative tolerance}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function determines unique rows in set of points.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: set of points, double [nPoints x 1/2/3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tol}}: geom relative precision, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{uniquePoints}}: set of unique points, double [nUniques x 1/2/3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [uniquePoints, indA, indC] = models.utilities.geomPublic.geomUnique( ...
 points, tol)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function geomUnique determines unique points \textit{uniquePoints} from set of points \textit{points}. Also index vectors \textit{indA}: indices of unique rows in initial set) and \textit{indC}: indices of initial points in unique set.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}geomUnique}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getAngleBetweenVectors: compute angle between two vectors}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:getAngleBetweenVectors}AToM:+models:+utilities:+geomPublic:getAngleBetweenVectors         
          \subsection*{getAngleBetweenVectors: compute angle between two vectors}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes angle between vector 1 defined in 3D Euclidean space by \textit{vect1} and 3D vector 2 \textit{vect2} .\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect1}}: 3D vector, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect2}}: 3D vector, double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: angle between vector 1 and vector 2, double [1 x 1] in [rad]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 angle = models.utilities.geomPublic.getAngleBetweenVectors(vect1, vect2)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function getAngleBetweenVectors computes angle between two vectors in 3D defined by \textit{vect1} and \textit{vect2}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}getAngleBetweenVectors}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getEllipseArcLength: compute length of ellipsearc}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:getEllipseArcLength}AToM:+models:+utilities:+geomPublic:getEllipseArcLength         
          \subsection*{getEllipseArcLength: compute length of ellipsearc}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This static method computes length of part of ellipseac specified by majorRadius, minorRadius, startAngle and arc angle.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{majorRadius}}: major axis radius, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{minorRadius}}: minor axis radius, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{startAngle}}: start angle of arc, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: arc length, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tolerance}}: numrical tolerance, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{length}}: length of ellipsearcs, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 length = models.utilities.geomPublic.getEllipseArcLength(majorRadius, ...
 minorRadius, startAngle, angle)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function getEllipseArcLength computes length of ellipsearcs specified by its properties: \textit{majorRadius}, \textit{minorRadius}, \textit{startAngle}, \textit{angle}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}getEllipseArcLength}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getLineIntersectingTwoPlanes: find intersection line between two planes}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:getLineIntersectingTwoPlanes}AToM:+models:+utilities:+geomPublic:getLineIntersectingTwoPlanes         
          \subsection*{getLineIntersectingTwoPlanes: find intersection line between two planes}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes line that is intersecting both planes defined in 3D.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{norm1}}: normal of planes from set 1, double [nP1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{point1}}: point on planes from set 1, double [nP1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{norm2}}: normal of planes from set 2, double [nP2 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{point2}}: point on planes from set 2, double [nP2 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isParallel}}: are planes parallel, logical [nP1 x nP2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{interVect}}: vector of line, double [nP1 x 3*nP2]
  \textbf{  .x}: x-coordinates, double [nV1 x nV2]
  \textbf{  .y}: y-coordinates, double [nV1 x nV2]
  \textbf{  .z}: z-coordinates, double [nV1 x nV2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{interPoint}}: point on line, double [nP1 x 3*nP2]
  \textbf{  .x}: x-coordinates, double [nV1 x nV2], in [m]
  \textbf{  .y}: y-coordinates, double [nV1 x nV2], in [m]
  \textbf{  .z}: z-coordinates, double [nV1 x nV2], in [m]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [isParallel, interVect, interPoint] = models.utilities.geomPublic. ...
 getLineIntersectingTwoPlanes(norm1, point1, norm2, point2)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function getLineIntersectingTwoPlanes finds intersection line of planes defined by their normal (\textit{norm1} and \textit{norm2}) and point (\textit{point1} and \textit{point2}). The curve is found in form of point (\textit{interPoint}) and vector (\textit{interVecto}).\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}getLineIntersectingTwoPlanes}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getPointsOnEllipseArc: compute points on ellipse arc}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:getPointsOnEllipseArc}AToM:+models:+utilities:+geomPublic:getPointsOnEllipseArc         
          \subsection*{getPointsOnEllipseArc: compute points on ellipse arc}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes position of points that defines an EllipseArc.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nPoints}}: number of points on EllipseArc, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{center}}: EllipseArc center position, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{majorVertex}}: EllipseArc major vertex point, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{minorVector}}: EllipseArc minor vertex point, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{startAngle}}: EllipseArc start angle, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: EllipseArc angle, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{dP}}: drawPoints, double [nPoints x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 dP = getPointsOnEllipseArc(nPoints, center, majorVector, minorVector,
 startAngle, angle)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Points \textit{dP} are computed on the EllipseArc defined by \textit{center}, \textit{majorVertex}, \textit{minorVertex}, \textit{startAngle}, \textit{angle}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}getPointsOnEllipseArc}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getPointsOnEquationCurve: compute points on EquationCurve}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:getPointsOnEquationCurve}AToM:+models:+utilities:+geomPublic:getPointsOnEquationCurve         
          \subsection*{getPointsOnEquationCurve: compute points on EquationCurve}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes position of points that defines EquationCurve.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nPoints}}: number of points on EllipseArc, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{interval}}: parameter interval, double [1 x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eqX}}: handle_function [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eqY}}: handle_function [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eqZ}}: handle\_function [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{dP}}: points on line, double [nPoints x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 dP = getPointsOnEquationCurve(nPoints, interval, eqX, eqY, eqZ)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Points \textit{dP} are computed on the EquationCurve defined by \textit{interval}, \textit{eqX}, \textit{eqY}, \textit{eqZ}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}getPointsOnEquationCurve}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getPointsOnLine: compute points on line segment}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:getPointsOnLine}AToM:+models:+utilities:+geomPublic:getPointsOnLine         
          \subsection*{getPointsOnLine: compute points on line segment}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes position of points that defines Line.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nPoints}}: number of points on Line, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{startPoint}}: double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{endPoint}}: double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{dP}}: points on Line, double [nPoints x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 dP = obj.getPointsOnLine(nPoints, startPoint, endPoint)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Points \textit{dP} are computed on the Line defined by \textit{startPoint}, \textit{endPoint}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}getPointsOnLine}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getPolygonArea: compute area of 2D polygon in 3D}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:getPolygonArea}AToM:+models:+utilities:+geomPublic:getPolygonArea         
          \subsection*{getPolygonArea: compute area of 2D polygon in 3D}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes area of a 2d polzgon (flat) in 3d space.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: 3D polygon nodes, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{area}}: area of polygon, double [1 x 3] in [rad]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [area, inLine, normal] = models.utilities.geomPublic.getPolygonArea(points)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function getPolygonArea computes area of polygon defined in 3D space by points specified in \textit{points}. In case all the polygon segments specified by \textit{points} are parallel, \textit{inLine} is set to true and area contains NaN.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}getPolygonArea}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getTriangleArea: compute signed area of triangle}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:getTriangleArea}AToM:+models:+utilities:+geomPublic:getTriangleArea         
          \subsection*{getTriangleArea: compute signed area of triangle}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes signed area of triuangle defined by three points: \textit{point1}, \textit{point2} and \textit{point3}.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{point1}}: first point position, double [1 x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{point2}}: second point position, double [1 x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{point3}}: third point position, double [1 x 3] in [m]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{area}}: signed area of triangle, double [1 x 1] in [m\^{}2]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 area = models.utilities.geomPublic.getTriangleArea(point1, point2, point3)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function getTriangleArea computes signed area of triangle defined by three points: \textit{point1}, \textit{point2} and \textit{point3}. The resulting area is: I] area \ensuremath{>} 0 - points are in CCW order, II] area \ensuremath{<} 0 - points in CW order, III] area = 0 - points are in one line.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}getTriangleArea}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getVectorAngles: compute angles between vector and coordinate axes X, Y, Z}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:getVectorAngles}AToM:+models:+utilities:+geomPublic:getVectorAngles         
          \subsection*{getVectorAngles: compute angles between vector and coordinate axes X, Y, Z}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes angles between vector defined in 3D Euclidean space and coordinate axes X [1 0 0], Y [0 1 0] and Z \{0 0 1\}.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: 3D vector, double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angles}}: angles between vector and axes, double [1 x 3] in [rad]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 angles = models.utilities.geomPublic.getVectorAngles(vect)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function getVectorAngles computes abgles between vector \textit{vect} in 3D and axes x [1, 0, 0], y [0, 1, 0] and z [0, 0, 1].\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}getVectorAngles}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getVectorNorm: compute norm of vector in 3D}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:getVectorNorm}AToM:+models:+utilities:+geomPublic:getVectorNorm         
          \subsection*{getVectorNorm: compute norm of vector in 3D}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This static method computes norm of vector defined in 3D Euclidean space.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: 3D vector, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{dim}}: dimension, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vNorm}}: norm of the vector, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 vNorm = models.utilities.geomPublic.getVectorNorm(vect)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function getVectorNorm computes norm of vector \textit{vect} in 3D.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}getVectorNorm}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{intersectLines2D: find intersection points between two sets of lines}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:intersectLines2D}AToM:+models:+utilities:+geomPublic:intersectLines2D         
          \subsection*{intersectLines2D: find intersection points between two sets of lines}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This static method finds intersection between two sets of lines in 2D plane.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{line1}}: points of set1 lines, double [2 x 2*N1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{lines}}: points of set2 lines, double [2 x 2*N2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tol}}: geometrical precision, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: intersection points between curves, cell [N1 x N2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{status}}: double [N1 x N2]
         0 - no intersection
         1 - intersection in one point
         2 - overlappping
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{param}}: parametric position of intersection points, cell [N1 x N2]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [points, status, param] = models.utilities.geomPublic. ...
 intersectLines2D(line1, line2)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Intersection points \textit{points} between a set of lines \textit{line1} and set of lines \textit{line2} are computed in 2D. The variable \textit{status} indicates how intersection ends: 0 - no intersection, 1 - lines intersect in one point, 2 - lines overlap between \textit{points(1,:)} and \textit{points(2,:)}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}intersectLines2D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{intersectLines3D: computes intersection point of two lines in 3D.}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:intersectLines3D}AToM:+models:+utilities:+geomPublic:intersectLines3D         
          \subsection*{intersectLines3D: computes intersection point of two lines in 3D.}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Implemented according to: \url{https://math.stackexchange.com/questions/270767/find-intersection-of-two-3d-lines} This is public function.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{X1, X2}}: start and end point of first line, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Y1, Y2}}: start and end point of second line, double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{I}}: intersection point coordinates, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{t}}: parameter of intersection point. If is in interval [0,1], intersection
     point lies between defining points, double [1 x 1]
 \end{IOVerbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}intersectLines3D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{isPolygonCounterClockWise: find out if polygon is CCW or not}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:isPolygonCounterClockWise}AToM:+models:+utilities:+geomPublic:isPolygonCounterClockWise         
          \subsection*{isPolygonCounterClockWise: find out if polygon is CCW or not}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function finds out if polygon specified by ordered points is in CCW (counterclockwise] order or in CW (clockwise) order.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: points of polygon, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{varargin}}:
           tolerance: geometry tolerance, double [1 x 1] in [m]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isCCW}}: true = counterclockwise, false = clockwise, logical [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{inLine}}: true = all points in one line, false = triangle, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [isCCW, inLine, area] = ...
 models.utilities.geomPublic.isPolygonCounterClockWise(points, tolerance)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function isPolygonCounterClockWise is used to determine if polygon specified by N 3D points \textit{points} is in CCW order (\textit{isCCW} = true) or in CW order (\textit{isCCW} = false). The tolerance of geometry is set to first value in \textit{varargin}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}isPolygonCounterClockWise}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{isTriangleCounterClockWise: find out if triangle is CCW or not}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:isTriangleCounterClockWise}AToM:+models:+utilities:+geomPublic:isTriangleCounterClockWise         
          \subsection*{isTriangleCounterClockWise: find out if triangle is CCW or not}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function finds out if triangle specified by three points in order: \textit{point1}, \textit{point2} and \textit{point3} is in CCW \}counterclockwise] order or in CW (clockwise order).\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{point1}}: first point position, double [1 x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{point2}}: second point position, double [1 x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{point3}}: third point position, double [1 x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{varargin}}:
           tolerance: geometry tolerance, double [1 x 1] in [m]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isCCW}}: true = counterclockwise, false = clockwise, logical [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{inLine}}: true = all points in one line, false = triangle, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [isCCW, inLine] = models.utilities.geomPublic.isTriangleCounterClockWise( ...
 point1, point2, point3, tolerance)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function isTriangleCounterClockWise is used to determine if triangle specified by three points \textit{point1}, \textit{point2} and \textit{point3} is in CCW order (\textit{isCCW} = true) or in CW order (\textit{isCCW} = false). The tolerance of geometry is set to first value in \textit{varargin}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}isTriangleCounterClockWise}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{makeVectorsPerpendicular: force two vectors to be perpendicular}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:makeVectorsPerpendicular}AToM:+models:+utilities:+geomPublic:makeVectorsPerpendicular         
          \subsection*{makeVectorsPerpendicular: force two vectors to be perpendicular}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function forces two vectors to be perpendicular. First vector remains the same and the second one is rotated in the plane defined by the vectors so that they are perpendicular.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect1}}: 3D vector, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect2}}: 3D vector, double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect2}}: 3D vector, double [1 x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 vect2 = models.utilities.geomPublic.makeVectorsPerpendicular(vect1, vect2)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function makeVectorsPerpendicular forces two vectors to be perpendicular by rotating the second vector in plane defined by the vectors.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}makeVectorsPerpendicular}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pointsEuclidDistance: computes Euclidean distances between points in 3D}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:pointsEuclidDistance}AToM:+models:+utilities:+geomPublic:pointsEuclidDistance         
          \subsection*{pointsEuclidDistance: computes Euclidean distances between points in 3D}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function computes distance between individual points and total length of the segments connecting all points.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: 3D points, double [N x 3] in [m]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{totalLength}}: length of the whole refracted line, double [1 x 1] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{sectionLengths}}: length of individual segments, double [(N - 1) x 1] in [m]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [totalLength, sectionLengths] = ...
 models.utilities.geomPublic.pointsEuclidDistance(points)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function pointsEuclidDistance computes Euclidean distances between 3D points.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}pointsEuclidDistance}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pointsGlobal2LocalCoords: transform object from global to local coordinates}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:pointsGlobal2LocalCoords}AToM:+models:+utilities:+geomPublic:pointsGlobal2LocalCoords         
          \subsection*{pointsGlobal2LocalCoords: transform object from global to local coordinates}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function transforms an object from global coordinate system ([1, 0, 0], [0, 1, 0], [0, 0, 1]) to local one \{defined by object\} \textit{origin}, \textit{localX}, \textit{localY} and \textit{localZ}.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: 3D points, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{origin}}: object center position, origin of coord system, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{localX}}: orientation of object's coordinate system X, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{localY}}: orientation of object's coordinate system Y, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{localZ}}: orientation of object's coordinate system Y, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{varargin}}:
           tolerance: optional, geometry tolerance, double [1 x 1], in [m]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: new position of points, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 points = models.utilities.geomPublic.pointsGlobal2LocalCoords(points,
 origin, localX, localY, localZ, tolerance)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function pointsGlobal2LocalCoords transforms points from global coordinate system to local one defined by three vectors \textit{localX}, \textit{localY}, \textit{localZ} and center point \textit{origin}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}pointsGlobal2LocalCoords}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pointsLocal2GlobalCoords: transforms object from local to global coordinates}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:pointsLocal2GlobalCoords}AToM:+models:+utilities:+geomPublic:pointsLocal2GlobalCoords         
          \subsection*{pointsLocal2GlobalCoords: transforms object from local to global coordinates}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function transforms an object from local coordinate system (defined for the object) to global one specified by three vectors globalX, globalY and globalZ.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: 3D points, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{origin}}: object center position, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{globalX}}: orientation of object in global coordinate system, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{globalY}}: orientation of object in global coordinate system, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{globalZ}}: orientation of object in global coordinate system, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{varargin}}:
           tolerance: optional, geometry tolerance, double [1 x 1], in [m]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: new position of points, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 points = models.utilities.geomPublic.pointsLocal2GlobalCoords(points,
 origin, globalX, globalY, globalZ)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function pointsLocal2GlobalCoords transforms points from their local coordinate system to global one defined by three vectors \textit{globalX}, \textit{globalY}, \textit{globalZ} and \textit{origin}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}pointsLocal2GlobalCoords}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pointsRotate: rotate points in 3D around vector by angle}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:pointsRotate}AToM:+models:+utilities:+geomPublic:pointsRotate         
          \subsection*{pointsRotate: rotate points in 3D around vector by angle}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This static method rotates points by angle around line defined by vector either starting at origin O and defined by \textit{vect} or gooing through two points defined in \textit{vect}.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: points in 3D, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: definition of rotation axis, double [1or2 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: rotation angle, double [1 x 1] in [rad]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: transformed points in 3D, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{transformMatrix}}: double [4 x 4]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [points, transformMatrix] = ...
 models.utilities.geomPublic.pointsRotate(points, vect, angle)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Object obj is rotated by angle in radians around axis specified by \textit{vect}. If \textit{vect} has one row, the rotation is made around line defined by Origin and point saved in \textit{vect}. If \textit{vect} has two rows, the rotatiuon is made around line defined by two points in \textit{vect}.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}pointsRotate}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pointsRotateX: rotate points around X-axis by angle}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:pointsRotateX}AToM:+models:+utilities:+geomPublic:pointsRotateX         
          \subsection*{pointsRotateX: rotate points around X-axis by angle}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function rotates points by angle in rad around global X-axis [1, 0, 0].\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: points in 3D, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: rotation angle, double [1 x 1] in [rad]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: transformed points in 3D, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{transformMatrix}}: double [4 x 4]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [points, transformMatrix] = ...
 models.utilities.geomPublic.pointsRotateX(points, angle)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Points are rotated by angle in radians around X-axis [1, 0, 0].\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}pointsRotateX}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pointsRotateY: rotate points around Y-axis by angle}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:pointsRotateY}AToM:+models:+utilities:+geomPublic:pointsRotateY         
          \subsection*{pointsRotateY: rotate points around Y-axis by angle}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function rotates points by angle in rad around Y-axis [0, 1, 0].\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: points in 3D, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: rotation angle, double [1 x 1] in [rad]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: transformed points in 3D, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{transformMatrix}}: double [4 x 4]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [points, transformMatrix] = models.utilities.geomPublic. ...
 pointsRotateY(points, angle)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Points are rotated by angle in radians around Y-axis [0, 1, 0].\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}pointsRotateY}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pointsRotateZ: rotate points around Z-axis by angle}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:pointsRotateZ}AToM:+models:+utilities:+geomPublic:pointsRotateZ         
          \subsection*{pointsRotateZ: rotate points around Z-axis by angle}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function rotates points by angle in rad around Z-axis [0, 0, 1].\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: points in 3D, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angle}}: rotation angle, double [1 x 1] in [rad]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: transformed points in 3D, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{transformMatrix}}: double [4 x 4]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [points, transformMatrix] = ...
 models.utilities.geomPublic.pointsRotateZ(points, angle)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Points are rotated by angle in radians around Z-axis [0, 0, 1].\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}pointsRotateZ}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pointsScale: scale points according to vector}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:pointsScale}AToM:+models:+utilities:+geomPublic:pointsScale         
          \subsection*{pointsScale: scale points according to vector}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function scales specified points according to vector. The individual dimensions of points are multiplied by values from specified vector.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: points in 3D, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: scaling vector, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{center}}: optional, cneter of transformation (default [0 0 0]), double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: transformed points in 3D, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{transformMatrix}}: double [4 x 4]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [points, transformMatrix] = ...
 models.utilities.geomPublic.pointsScale(points, vect, center)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Points are scaled so that any dimension of values in \textit{points} is multiplied by corresponding value from vector \textit{vect}. The object is moved to \textit{center} before scale operation, and then back after the scale operation.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}pointsScale}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pointsTranslate: translates object according to vector}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:pointsTranslate}AToM:+models:+utilities:+geomPublic:pointsTranslate         
          \subsection*{pointsTranslate: translates object according to vector}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function translates specified points by vector in meters.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: points in 3D, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: translation vector, double [1 x 3] in [m]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: transformed points in 3D, double [N x 3] in [m]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{transformMatrix}}: double [4 x 4]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [points, transformMatrix] = ...
 models.utilities.geomPublic.pointsTranslate(points, vect)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Points are translated to new position according to vector \textit{vect} in meters.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}pointsTranslate}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{repelem: repeats elements of vect rep-times}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:repelem}AToM:+models:+utilities:+geomPublic:repelem         
          \subsection*{repelem: repeats elements of vect rep-times}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function repeats elements of n-times according to rep values.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vect}}: vector of values, double [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{rep}}: count how many times should be repeated, double [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newVect}}: vector of repeated values, double [1 x M]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 newVect = models.utilities.geomPublic.repelem(vect, rep)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function repelem repeates all elements of vector \textit{vect} according to values in vector \textit{rep} having the same size.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}repelem}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{roundToRelativeTolerance: round to relative tolerance}
          \vspace{1em}
          \label{AToM:+models:+utilities:+geomPublic:roundToRelativeTolerance}AToM:+models:+utilities:+geomPublic:roundToRelativeTolerance         
          \subsection*{roundToRelativeTolerance: round to relative tolerance}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function round values to relative tolerance according to their max abs value.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{values}}: set of values, double [nVals1 x nVals2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tol}}: geom relative precision, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{uniquePoints}}: set of unique points, double [nUniques x 1/2/3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 values = models.utilities.geomPublic.roundToRelativeTolerance(values, tol)
 \end{Verbatim}
 \vspace{2pt}\begin{par}Function roundToRelativeTolerance throws back values \textit{\_values rounded to a relative tolerance \_tol} accrodnig to their max abs value.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+geomPublic\ensuremath{\backslash}roundToRelativeTolerance}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+utilities/+matrixOperators/+MoM2D/+SMatrix}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+utilities/+matrixOperators/+MoM2D/+SMatrix}}~}
\fancyhead[RO,RE]{+models/+utilities/+matrixOperators/+MoM2D/+SMatrix}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeDS: derivative of S matrix}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:computeDS}AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:computeDS         
          \subsection*{computeDS: derivative of S matrix}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}S matrix assembled according to \url{https://arxiv.org/pdf/1709.09976.pdf}\end{par}\vspace{2pt}\begin{par}matrix properties:\end{par}\begin{Verbatim}
 odd rows  - TE modes
 even rows - TM modes
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: frequency, double [1 x 1]
 \end{IOVerbatim}
 \begin{Verbatim}
 INUPUTS
  (optional)
  maxDegreeL:      maximal degree of used spherical functions,
                    double [1 x 1], default value 15
  quadratureOrder: order of Gaussian quadrature, double [1 x 1],
                    integers <1 , 12>, default value 1
 \end{Verbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{dS}}:          S matrix derivative, double [N x M]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 dS = computeDS(mesh, basisFcns, frequency)
 dS = computeDS(mesh, basisFcns, frequency)
 dS = computeDS(mesh, basisFcns, frequency, ...
                        maxDegreeL, quadratureOrder)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+SMatrix\ensuremath{\backslash}computeDS}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeS: Calculates S matrix}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:computeS}AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:computeS         
          \subsection*{computeS: Calculates S matrix}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}S matrix assembled according to \url{https://arxiv.org/pdf/1709.09976.pdf}\end{par}\vspace{2pt}\begin{par}matrix properties:\end{par}\begin{Verbatim}
 odd rows  - TE modes
 even rows - TM modes
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: frequency, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  (optional)
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{maxDegreeL}}:      maximal degree of used spherical functions,
                    double [1 x 1], default value 15
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{quadratureOrder}}: order of Gaussian quadrature, double [1 x 1],
                    integers <1 , 12>, default value 1
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{wavesType}}: type of waves, double [1 x 1]
             1 - regular waves, z = spherical Bessel function
             2 - irregular waves, z = spherical Neumann function
             3 - ingoing waves, z = spherical Hankel function 1
             4 - outgoing waves, z = spherical Hankel function 2
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nCross}}: if 'nCross' string is present, (psi \ensuremath{\backslash}dot (nTria \ensuremath{\backslash}times u)) is
          calculated instead of (psi \ensuremath{\backslash}dot u), string
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{S}}:           S matrix,   double [N x M]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{indexMatrix}}: matrix of ordering in S matrix, double [5 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 S = computeS(mesh, basisFcns, frequency)
 [S, indexMatrix] = computeS(mesh, basisFcns, frequency)
 [S, indexMatrix] = computeS(mesh, basisFcns, frequency, ...
                        maxDegreeL, quadratureOrder)
 [S, indexMatrix] = computeS(mesh, basisFcns, frequency, ...
                        maxDegreeL, quadratureOrder, wavesType)
 [S, indexMatrix] = computeS(mesh, basisFcns, frequency, ...
                        maxDegreeL, quadratureOrder, wavesType, nCross)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+SMatrix\ensuremath{\backslash}computeS}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{functionR: radial part of spherical waves}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:functionR}AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:functionR         
          \subsection*{functionR: radial part of spherical waves}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{degreeL}}: vector of degrees L, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{kR}}:      vector of radial coordinates, double [M x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{p}}:       type of waves, double [1 x 1]
             1 - regular waves, z = spherical Bessel function
             2 - irregular waves, z = spherical Neumann function
             3 - ingoing waves, z = spherical Hankel function 1
             4 - outgoing waves, z = spherical Hankel function 2
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{R1}}:   R1 radial function, complex double [N x M]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{R2}}:   R2 radial function, complex double [N x M]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{R3}}:   R3 radial function, complex double [N x M]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{zD}}:   derivatve of propper spherical bessel function,
        complex double [N x M]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+SMatrix\ensuremath{\backslash}functionR}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{functionU: spherical vector waves u}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:functionU}AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:functionU         
          \subsection*{functionU: spherical vector waves u}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{degreeL}}: vector of degrees L, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{orderM}}:  vector of orderes M, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{theta}}:   vector of theta coordinates, double [M x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{phi}}:     vector of phi coordinates, double [M x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{kR}}:      vector of radial coordinates, double [M x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{p}}:       type of waves, double [1 x 1]
             1 - regular waves, z = spherical Bessel function
             2 - irregular waves, z = spherical Neumann function
             3 - ingoing waves, z = spherical Hankel function 1
             4 - outgoing waves, z = spherical Hankel function 2
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{u12}}:  spherical vector wave u1 with sigma = 2,
        complex double [N x M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{u11}}:  spherical vector wave u1 with sigma = 1,
        complex double [N x M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{u22}}:  spherical vector wave u2 with sigma = 2,
        complex double [N x M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{u21}}:  spherical vector wave u2 with sigma = 1,
        complex double [N x M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{u32}}:  spherical vector wave u3 with sigma = 2,
        complex double [N x M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{u31}}:  spherical vector wave u3 with sigma = 1,
        complex double [N x M x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+SMatrix\ensuremath{\backslash}functionU}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{functionY: vector spherical harmonics Y}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:functionY}AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:functionY         
          \subsection*{functionY: vector spherical harmonics Y}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{degreeL}}: vector of degrees L, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{orderM}}:  vector of orderes M, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{theta}}:   vector of theta coordinates, double [M x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{phi}}:     vector of phi coordinates, double [M x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Y1}}:   Y1 vector spherical hamonic, complex double [N x M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Y2}}:   Y2 vector spherical hamonic, complex double [N x M x 3]
  Y3    Y3 vector spherical hamonic, complex double [N x M x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+SMatrix\ensuremath{\backslash}functionY}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{lmax: gives estimate of highest L order for spherical expansion}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:lmax}AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:lmax         
          \subsection*{lmax: gives estimate of highest L order for spherical expansion}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{k0List}}: (a vector of) normalized electrical size(s)
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}:  points, double [N x 3], e.g. nodes = Mesh.nodes
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Lmax}}: highest degree of Legendre polynomial to be used
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 Lmax = lmax(k0List, nodes)
 \end{Verbatim}
 \vspace{2pt}\begin{par}See [1] Tayli, Capek, Akrou, Losenicky, Jelinek, Gustafsson: Accurate and     Efficient Evaluation of Characteristic Modes, IEEE TAP, 2018.     \url{https://arxiv.org/pdf/1709.09976.pdf}\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+SMatrix\ensuremath{\backslash}lmax}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{totalSphericalModes: determines how many spherical waves are used}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:totalSphericalModes}AToM:+models:+utilities:+matrixOperators:+MoM2D:+SMatrix:totalSphericalModes         
          \subsection*{totalSphericalModes: determines how many spherical waves are used}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Lmax}}: normalized electrical size
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{sphWaves}}: highest degree of Legendre polynomial to be used
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 sphWaves = totalSphericalModes(Lmax)
 \end{Verbatim}
 \vspace{2pt}\begin{par}See [1] Tayli, Capek, Akrou, Losenicky, Jelinek, Gustafsson: Accurate and     Efficient Evaluation of Characteristic Modes, IEEE TAP, 2018.     \url{https://arxiv.org/pdf/1709.09976.pdf}\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+SMatrix\ensuremath{\backslash}totalSphericalModes}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+utilities/+matrixOperators/+MoM2D/+batch}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+utilities/+matrixOperators/+MoM2D/+batch}}~}
\fancyhead[RO,RE]{+models/+utilities/+matrixOperators/+MoM2D/+batch}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{evaluate: gathers all matrix operators required by the user}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+batch:evaluate}AToM:+models:+utilities:+matrixOperators:+MoM2D:+batch:evaluate         
          \subsection*{evaluate: gathers all matrix operators required by the user}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function generates basis functions and evaluate all matrices, for
 the complete list see batch.getList
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Mesh}}:   mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{fList}}:  frequency list, double [1 x F]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{ZsList}}: list of surface impedances [1 x F]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{varargin implemented in property-value pairs, the properties are}}:
   'requests', see getList(), default: {'Z', 'omW', 'Rmat'}
   'normalize', {true | (false)}, true: all operators in Ohms
   'quadOrder', {1, (2), ..., 12}
   'symmetrize', {true | (false)}, true: all square operators symmetrized
   'verbosity', {0, 1, (2)}
   'usegpu', {true | (false)}, true: MoM evaluted on GPU (if possible)
   'lmax',    \{integer\}, order of L index for evaluation of S matrices
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{OP}}: structure with all operators precalculated, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tt}}: total computational time in seconds [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [OP, tt] = models.utilities.matrixOperators.MoM2D.batch.evaluate(..
            Mesh, fList, ZsList, varargin)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+batch\ensuremath{\backslash}evaluate}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getList:: returns a list of matrix operators accesible via batch.evaluate}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+batch:getList}AToM:+models:+utilities:+matrixOperators:+MoM2D:+batch:getList         
          \subsection*{getList:: returns a list of matrix operators accesible via batch.evaluate}
 
          \begin{mdframed}
          \vspace{5pt}
          
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+batch\ensuremath{\backslash}getList}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{initialize:: create empty OP structure for batch.evaluate wrapper}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+batch:initialize}AToM:+models:+utilities:+matrixOperators:+MoM2D:+batch:initialize         
          \subsection*{initialize:: create empty OP structure for batch.evaluate wrapper}
 
          \begin{mdframed}
          \vspace{5pt}
          
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+batch\ensuremath{\backslash}initialize}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+utilities/+matrixOperators/+MoM2D/+electricMoment}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+utilities/+matrixOperators/+MoM2D/+electricMoment}}~}
\fancyhead[RO,RE]{+models/+utilities/+matrixOperators/+MoM2D/+electricMoment}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeP: compute electric moment operator}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+electricMoment:computeP}AToM:+models:+utilities:+matrixOperators:+MoM2D:+electricMoment:computeP         
          \subsection*{computeP: compute electric moment operator}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Compute electric moment operator  If frequency is not set, results corresponds to p0 in  p = 1i / (2*pi*frequency) * p0; i.e. to results with  frequency = 1i / (2*pi).\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions, struc [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: frequency list, double [nFreq x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{P}}: electric moment, double [nEdges x nEdges]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{p}}:
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [P, p] = computeP(mesh, basisFcns)
 [P, p] = computeP(mesh, basisFcns, frequency)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+electricMoment\ensuremath{\backslash}computeP}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+utilities/+matrixOperators/+MoM2D/+farfield}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+utilities/+matrixOperators/+MoM2D/+farfield}}~}
\fancyhead[RO,RE]{+models/+utilities/+matrixOperators/+MoM2D/+farfield}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeU: compute radiation intensity matrix}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+farfield:computeU}AToM:+models:+utilities:+matrixOperators:+MoM2D:+farfield:computeU         
          \subsection*{computeU: compute radiation intensity matrix}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This fucntions evaluate radiation intensity matrix and farfield vectors. Electric far field is defined as F(e,r0) = -1j*k*Z0/(4*pi) * int(e .* J(r) * exp(1j*k* r0 dot r) dS Using matrices, it is F(e\_phi,r0) = Fphi*I and analogously for Ftheta. Radiation intensity is defined as U(e,r0) = abs(F(e,r0))\^{}2 / (2*Z0) Using matrices, it is U(e\_phi,r0) = I'*U*I where U = Fphi'*Fphi / (2*Z0). Analogous relation holds for theta component. see Jelinek, Capek: Optimal Currents on Arbitrarily Shaped Surfaces IEEE-TAP, 2017, Eqs. (49)-(56)\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFunc}}: basis functions, struc [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: frequency, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{theta}}: theta angle, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{phi}}: phi angle, double, [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{component}}:
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{U}}: radiation intensity matrix, double [nBF x nBF]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Fphi}}:
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [U, Fphi, Ftheta] = computeU(mesh, basisFunc, frequency, theta, phi)
 [U, Fphi, Ftheta] = computeU(mesh, basisFunc, frequency, theta, ...
   phi, component)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+farfield\ensuremath{\backslash}computeU}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+utilities/+matrixOperators/+MoM2D/+magneticMoment}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+utilities/+matrixOperators/+MoM2D/+magneticMoment}}~}
\fancyhead[RO,RE]{+models/+utilities/+matrixOperators/+MoM2D/+magneticMoment}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeM: compute magnetic moment operator}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+magneticMoment:computeM}AToM:+models:+utilities:+matrixOperators:+MoM2D:+magneticMoment:computeM         
          \subsection*{computeM: compute magnetic moment operator}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Compute magnetic moment operator\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions, struc [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{M}}: magnetic moment, double [nEdges x nEdges]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{m}}:
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [M, m] = computeM(mesh, basisFcns)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+magneticMoment\ensuremath{\backslash}computeM}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+utilities/+matrixOperators/+MoM2D/+ohmicLosses}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+utilities/+matrixOperators/+MoM2D/+ohmicLosses}}~}
\fancyhead[RO,RE]{+models/+utilities/+matrixOperators/+MoM2D/+ohmicLosses}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeL: Compute L matrix for calculation of ohmic losses}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+ohmicLosses:computeL}AToM:+models:+utilities:+matrixOperators:+MoM2D:+ohmicLosses:computeL         
          \subsection*{computeL: Compute L matrix for calculation of ohmic losses}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Compute L matrix for calculation of ohmic losses\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions, struc [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{rho}}: [nTria x 1] for  mode='triangles', [nEdges x 1] for mode='edges'
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mode}}:
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{L}}: lossy matrix [nEdges x nEdges]
 \end{IOVerbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+ohmicLosses\ensuremath{\backslash}computeL}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{lossymatrix: calculate L matrix for calculation of ohmic losses}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+ohmicLosses:lossyMatrix}AToM:+models:+utilities:+matrixOperators:+MoM2D:+ohmicLosses:lossyMatrix         
          \subsection*{lossymatrix: calculate L matrix for calculation of ohmic losses}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}calculate L matrix for calculation of ohmic losses\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions, struc [1 x 1]
  rhoTria [nTria x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  L .. lossy matrix [nEdges x nEdges]
  T
  F
  FL .. transform structure for rhoEdge -> rhoTria [6 x 5 x nTria]
   1st dimension: 6 edges for each triangle
   2nd dimension:
    FL(:, 1, iTria) .. number of edge 1
    FL(:, 2, iTria) .. number of edge 2
    FL(:, 3, iTria) .. contribution to lossy matrix
    FL(:, 4, iTria) .. sign of edge 1
    FL(:, 5, iTria) .. sign of edge 2
 \end{IOVerbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+ohmicLosses\ensuremath{\backslash}lossyMatrix}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{rhoEdge2rhoTria: recalculate resistivitiy of triangles from edges}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+ohmicLosses:rhoEdge2rhoTria}AToM:+models:+utilities:+matrixOperators:+MoM2D:+ohmicLosses:rhoEdge2rhoTria         
          \subsection*{rhoEdge2rhoTria: recalculate resistivitiy of triangles from edges}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}: mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{FL}}: transform structure for rhoEdge -> rhoTria [6 x 5 x nTria]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{rhoEdge}}: [nEdges x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{I}}: [nEdges x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{rhoTria}}: [nTria x 1]
 \end{IOVerbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+ohmicLosses\ensuremath{\backslash}rhoEdge2rhoTria}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{thinSheetCoef: calculate lossy coeficient derived for thin-sheet approximation}
          \vspace{1em}
          \label{AToM:+models:+utilities:+matrixOperators:+MoM2D:+ohmicLosses:thinSheetCoef}AToM:+models:+utilities:+matrixOperators:+MoM2D:+ohmicLosses:thinSheetCoef         
          \subsection*{thinSheetCoef: calculate lossy coeficient derived for thin-sheet approximation}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  frequency
  sigma
  t
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  F [1x1]
 \end{IOVerbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+matrixOperators\ensuremath{\backslash}+MoM2D\ensuremath{\backslash}+ohmicLosses\ensuremath{\backslash}thinSheetCoef}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+utilities/+meshPublic}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+utilities/+meshPublic}}~}
\fancyhead[RO,RE]{+models/+utilities/+meshPublic}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{centerMesh: Shifts nodes of the mesh to the origin of coordinate system}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:centerMesh}AToM:+models:+utilities:+meshPublic:centerMesh         
          \subsection*{centerMesh: Shifts nodes of the mesh to the origin of coordinate system}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}INPUTS  nodes: point coordinates, double [N x 3]\end{par}\vspace{2pt}\begin{par}OUTPUTS  nodes: point coordinates, double [N x 3]\end{par}\vspace{2pt}\begin{par}SYNTAX  nodes = models.utilities.meshPublic.centreMesh(nodes);\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}centerMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{commonEdgeOfTwoTriangles: Returns ID of common edge of two adjacent triangles}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:commonEdgeOfTwoTriangles}AToM:+models:+utilities:+meshPublic:commonEdgeOfTwoTriangles         
          \subsection*{commonEdgeOfTwoTriangles: Returns ID of common edge of two adjacent triangles}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}The function returns ID of edge between two adjacent triangles.\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}commonEdgeOfTwoTriangles}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{deleteConnectivityElement: deletes triangles or tetrahedrons from a given mesh}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:deleteConnectivityElements}AToM:+models:+utilities:+meshPublic:deleteConnectivityElements         
          \subsection*{deleteConnectivityElement: deletes triangles or tetrahedrons from a given mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function takes nodes a their connections
 (planar triangulation and tetrahedral meshes),
 which form a mesh in 3D space.
 It outputs new mesh without given connectivity list elements.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: node coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: mesh connectivity, double [N x (3, 4)]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{elementsToDelete}}: connectivity elements to delete from the mesh, double [N x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNodes}}: new set of nodes, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newConnectivityList}}: new set of connections, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [newNodes, newConnectivityList] =
 models.utilities.meshPublic.elementsToDelete(nodes, connectivityList,
 elementsToDelete);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}deleteConnectivityElements}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{deleteEdges: deletes edges from given mesh}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:deleteEdges}AToM:+models:+utilities:+meshPublic:deleteEdges         
          \subsection*{deleteEdges: deletes edges from given mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function takes nodes a their connections
 (planar triangulation and tetrahedral meshes),
 which form a mesh in 3D space.
 It outputs a new mesh without given edges.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: connectivity of nodes, double [N x (3, 4)]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edgesToDelete}}: edges to delete from the mesh, double [N x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNodes}}: new set of nodes, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newConnectivityList}}: new set of connections, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [newNodes, newConnectivityList] =
 models.utilities.meshPublic.deleteEdges(nodes, connectivityList, edgesToDelete);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}deleteEdges}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{deleteNodes: deletes nodes from given mesh}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:deleteNodes}AToM:+models:+utilities:+meshPublic:deleteNodes         
          \subsection*{deleteNodes: deletes nodes from given mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function takes nodes a their connections
 (planar triangulation and tetrahedral meshes),
 which form a mesh in 3D space.
 It outputs a new mesh without nodes specified in nodes.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: connectivity of nodes, double [N x (3, 4)]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: points to delete from the mesh, double [N x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNodes}}: new set of points, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newConnectivityList}}: new set of connections, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [newNodes, newConnectivityList] =
 models.utilities.meshPublic.deleteNodes(nodes, connectivityList, nodesToDelete);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}deleteNodes}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{edgeSymPlanes: get information about edges touching symmetry plane}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:edgeSymPlanes}AToM:+models:+utilities:+meshPublic:edgeSymPlanes         
          \subsection*{edgeSymPlanes: get information about edges touching symmetry plane}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 The function returns information of edges belonging to symmetry planes.
 The _symPlaneInfo_ contains 1 on positions where the edge touches given
 symmetry plane ([0 1 0] means that edge is lying in plane XZ).
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: node coordinates
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges}}: node IDs of edges
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{symPlaneInfo}}: symmetry plane information
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 symPlaneInfo = models.utilities.meshPublic.edgeSymPlanes(nodes, edges);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}edgeSymPlanes}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{exportGeo: exports mesh to GEO file}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:exportGeo}AToM:+models:+utilities:+meshPublic:exportGeo         
          \subsection*{exportGeo: exports mesh to GEO file}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: coordinates of points, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{triangles}}: pointers on nodes which represents triangles of mesh, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{filePath}}: path to output directory, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{fileName}}: name of the GEO file, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 models.utilities.meshPublic.exportGeo(nodes, connectivityList, path, name);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}exportGeo}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{exportNastran: exports mesh to NASTRAN file}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:exportNastran}AToM:+models:+utilities:+meshPublic:exportNastran         
          \subsection*{exportNastran: exports mesh to NASTRAN file}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Creates file is NASTRAN - high-precision data format.
 Data format: 8/16/16/16/16
              8/16
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: coordinates of points, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges}}: pointers on nodes which represents edges of mesh, double [N x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{triangles}}: pointers on nodes which represents triangles of mesh, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tetrahedrons}}: pointers on nodes which represents tetrahedrons of mesh, double [N x 4]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{filePath}}: path to output directory, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{fileName}}: name of the NASTRAN file, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 models.utilities.meshPublic.exportNastran(nodes, edges, triangles, tetrahedrons, path, name);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}exportNastran}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getAreaTriangle: calculate area of triangles.}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getAreaTriangle}AToM:+models:+utilities:+meshPublic:getAreaTriangle         
          \subsection*{getAreaTriangle: calculate area of triangles.}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: points coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: points number for each triangle, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{area}}: areas of triangles, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 area = models.utilities.meshPublic.getAreaTriangle(nodes, connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getAreaTriangle}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getBoundary2D: returns outer edges of planar triangulation}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getBoundary2D}AToM:+models:+utilities:+meshPublic:getBoundary2D         
          \subsection*{getBoundary2D: returns outer edges of planar triangulation}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function returns set of boundary edges which are specified by
 triangulation connectivityList and nodes.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: triangle vertices, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges}}: set of boundary edges in the triangulation, double [N x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{boundaryNodes}}: set of boundary nodes in the triangulation, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [edges, boundaryNodes] = models.utilities.meshPublic.getBoundary2D(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getBoundary2D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getBoundary3D: returns outer edges of of connected triangles/tetrahedrons in 3D}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getBoundary3D}AToM:+models:+utilities:+meshPublic:getBoundary3D         
          \subsection*{getBoundary3D: returns outer edges of of connected triangles/tetrahedrons in 3D}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function returns set of boundary edges which are specified by
 triangulation given by connectivityList and nodes.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: triangle/tetrahedra connectivity, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges}}: set of boundary edges in the mesh, double [N x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{boundaryNodes}}: set of boundary nodes in the mesh, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [edges, newNodes] = models.utilities.meshPublic.getBoundary3D(nodes, connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getBoundary3D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getCenterSegment: center of segment}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getCenterSegment}AToM:+models:+utilities:+meshPublic:getCenterSegment         
          \subsection*{getCenterSegment: center of segment}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: nodes coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges}}: nodes number for each segment, double [N x 2]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{center}}: coorddinates of center, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 center = models.utilities.meshPublic.getCenterSegment(nodes, edges);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getCenterSegment}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{Radius: and center of the smallest circumscribing sphere}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getCircumsphere}AToM:+models:+utilities:+meshPublic:getCircumsphere         
          \subsection*{Radius: and center of the smallest circumscribing sphere}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This function evaluates radius and center of the smallest circumscribing sphere.\end{par}\vspace{2pt}\begin{par}INPUTS  nodes: points, double [N x 3]\end{par}\vspace{2pt}\begin{par}OUTPUTS  r: radius, double [N x 1]  center: radius vector of the center, double [1 x 3]\end{par}\vspace{2pt}\begin{par}SYNTAX\end{par}\vspace{2pt}\begin{par}[r, center] = getCircumsphere(nodes)\end{par}
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getCircumsphere}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getEdgeLengthTriangle: calculate edges length of triangle}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getEdgeLengthTriangle}AToM:+models:+utilities:+meshPublic:getEdgeLengthTriangle         
          \subsection*{getEdgeLengthTriangle: calculate edges length of triangle}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: points coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: points number for each triangle, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edge}}: edge length, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 edge = models.utilities.meshPublic.getEdgeLengthTriangle(nodes, connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getEdgeLengthTriangle}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getEdges: returns edges in triangulation}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getEdges}AToM:+models:+utilities:+meshPublic:getEdges         
          \subsection*{getEdges: returns edges in triangulation}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function returns set of edges which are specified by triangulation
 connectivityList for triangle meshes.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: triangle vertices, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges}}: set of edges in triangulation connectivityList, double [N x 2]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [edges] = models.utilities.meshPublic.getEdges(connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getEdges}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getInnerEdges: returns edges in triangulation}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getInnerNodes}AToM:+models:+utilities:+meshPublic:getInnerNodes         
          \subsection*{getInnerEdges: returns edges in triangulation}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function returns set of inner edges which are specified by
 connectivityList on nodes.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: triangle vertices, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{innerNodes}}: set of inner nodes in triangulation, double [N x 2]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [innerNodes] = models.utilities.meshPublic.getInnerNodes(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getInnerNodes}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getLengthSegment: calculate length of segment}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getLengthSegment}AToM:+models:+utilities:+meshPublic:getLengthSegment         
          \subsection*{getLengthSegment: calculate length of segment}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: points coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges}}: points number for each segment, double [N x 2]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{length}}: length of segment, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 lengthSegment = models.utilities.meshPublic.getLengthSegment(nodes, edges);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getLengthSegment}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getLocalCoordinateSystem: get objects local coordinate system}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getLocalCoordinateSystem}AToM:+models:+utilities:+meshPublic:getLocalCoordinateSystem         
          \subsection*{getLocalCoordinateSystem: get objects local coordinate system}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This method determines local coordinate system of a polygon.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: 3D points, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{origin}}: coordinate system origin if interest, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{localX}}: X axis direction, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{localX}}: Y axis direction, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{localX}}: Z axis direction, double [1 x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [origin, localX, localY, localZ] = models.utilities.meshPublic.
    getLocalCoordinateSystem(points);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getLocalCoordinateSystem}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getMeshData2D: computes information necessary for MoM computations}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getMeshData2D}AToM:+models:+utilities:+meshPublic:getMeshData2D         
          \subsection*{getMeshData2D: computes information necessary for MoM computations}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function loads data from mesh and outputs struct with data
 necessary for MoM.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: triangle vertices, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{meshData}}: structure with following items
               -nodes, triangulation nodes, double [N x 3]
               -connectivityList, triangulation connectivity list, double [N x 3]
               -edges, triangulation edges, double [N x 2]
               -edgeCentroids, center point of each edge, double [N x 3]
               -edgeLengths, length of each edge, double [N x 1]
               -triangleAreas, area of each triangle, double [N x 1]
               -triangleCentroids, center points of each triangle, double [N x 3]
               -triangleEdges, indices to edges, double [N x 3]
               -triangleNormals, normals to each triangle, double [N x 3]
               -nNodes, number of nodes, double [1 x 1]
               -nEdges, number of edges, double [1 x 1]
               -nTriangles, number of triangles, double [1 x 1]
               -normDistanceA, radius of circumsphere, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [meshData] = models.utilities.meshPublic.getMeshData2D(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getMeshData2D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getMeshData3D: computes information necessary for MoM3D computations}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getMeshData3D}AToM:+models:+utilities:+meshPublic:getMeshData3D         
          \subsection*{getMeshData3D: computes information necessary for MoM3D computations}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function loads data from tetrahedron mesh and outputs struct with
 data necessary for MoM3D.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: tetrahedrna connectivity, double [N x 4]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{regions}}: tetrahedrna material regions, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{normDistance}}: normalization size, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{meshData}}: structure with following items
               -nodes, tetrahedrization nodes, double [N x 3]
               -connectivityList, tetrahedrization connectivity list, double [N x 4]
               -triangleAreas, area of each triangle, double [N x 1]
               -triangleCentroids, center points of each triangle, double [N x 3]
               -triangleNormals, normals of each triangle, double [N x 3]
               -tetrahedronCentroids, centroid of each tetrahedron, double [N x 3]
               -tetrahedronVolume, volume of each tetrahedron, double [N x 1]
               -tetrahedronTriangles, triangles (facets) of each tetrahedron, double [N x 4]
               -tetrahedronNormalSigns, normals' signs of each triangle, double [N x 4]
               -tetrahedronRegions, material regions of tetrahedrons, double [N x 1]
               -nRegions, number of material regions of tetrahedrons, double [1 x 1]
               -nTetra, number of tetrahedrons, double [1 x 1]
               -nTria, number of triangles, double [1 x 1]
               -circumRadius, radius of circumsphere, double [1 x 1]
               -normDistance, normalization of circumRadius and nodes, double [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [meshData] = models.utilities.meshPublic.getMeshData3D(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getMeshData3D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getTetrahedronCentroids: returns centroids of all tetrahedrons}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getTetrahedronCentroids}AToM:+models:+utilities:+meshPublic:getTetrahedronCentroids         
          \subsection*{getTetrahedronCentroids: returns centroids of all tetrahedrons}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: tetrahedrna connectivity, double [N x 4]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{centroids}}: tetrahedrons' centroids [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [centroids] = models.utilities.meshPublic.getTetrahedronCentroids(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getTetrahedronCentroids}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getTetrahedronFace2CenterNormals: returns normals of all face to tetrahedra center normals}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getTetrahedronFace2CenterNormals}AToM:+models:+utilities:+meshPublic:getTetrahedronFace2CenterNormals         
          \subsection*{getTetrahedronFace2CenterNormals: returns normals of all face to tetrahedra center normals}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{triangleCentroids}}: centroid of each triangle, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tetrahedronCentroids}}: centroid points of each tetrahedron, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tetrahedronTriangles}}: tetrahedron of each triangle, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{triangleNormals}}: triangle normals, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{normals}}:
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{signs}}: signs of each normal [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [normals, signs] = models.utilities.meshPublic.getTetrahedronFace2CenterNormals(...
 triangleCentroids, tetrahedronCentroids, tetrahedronTriangles, triangleNormals);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getTetrahedronFace2CenterNormals}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getTetrahedronVolume: returns volumes of all tetrahedrons}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getTetrahedronVolume}AToM:+models:+utilities:+meshPublic:getTetrahedronVolume         
          \subsection*{getTetrahedronVolume: returns volumes of all tetrahedrons}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: tetrahedrna connectivity, double [N x 4]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{volume}}: volume of each tetrahedron [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [volume] = models.utilities.meshPublic.getTetrahedronVolume(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getTetrahedronVolume}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getTriangleAreas: return triangle areas}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getTriangleAreas}AToM:+models:+utilities:+meshPublic:getTriangleAreas         
          \subsection*{getTriangleAreas: return triangle areas}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: node coordinates, double [nNodes x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{triangleNodes}}: triangle node indices, double [nTriangles x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edgeLengths}}: triangle edge lengths, double [nTriangles x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{triangleEdges}}: triangle edge indices, double [nTriangles x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{triangleAreas}}: triangle areas, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 triangleAreas = getTriangleAreas(nodes, triangleNodes)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getTriangleAreas}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getTriangleCentroids: returns centroids of all triangles}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getTriangleCentroids}AToM:+models:+utilities:+meshPublic:getTriangleCentroids         
          \subsection*{getTriangleCentroids: returns centroids of all triangles}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: triangle connectivity, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{centroids}}: triangle centroids, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [centroids] = models.utilities.meshPublic.getTriangleCentroids(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getTriangleCentroids}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{triangleCircumferences: returns circumferences of all trinangles}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getTriangleCircumferences}AToM:+models:+utilities:+meshPublic:getTriangleCircumferences         
          \subsection*{triangleCircumferences: returns circumferences of all trinangles}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: triangle connectivity, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{circumferences}}: triangle circumferences, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [circumferences] = models.utilities.meshPublic.getTriangleCircumferences(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getTriangleCircumferences}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getTriangleEdgeIndices: creates list of triangle edges according to triangle nodes}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getTriangleEdgeIndices}AToM:+models:+utilities:+meshPublic:getTriangleEdgeIndices         
          \subsection*{getTriangleEdgeIndices: creates list of triangle edges according to triangle nodes}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function constructs local edges inside given triangles, makes unique list
 of them (_edges_) and expresses local edges as pointers (_connectivityList_).
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: list of triangle nodes, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges}}: sorted list of edges, double [N x 2]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{triangleEdges}}: pointers to global list of edges, double [nTriangles x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [triangleEdges] =
 models.utilities.meshPublic.getTriangleEdgeIndices(connectivityList, edges);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getTriangleEdgeIndices}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getTriangleNormals: returns normals of all triangles}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getTriangleNormals}AToM:+models:+utilities:+meshPublic:getTriangleNormals         
          \subsection*{getTriangleNormals: returns normals of all triangles}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: triangle connectivity, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{normals}}: triangle normals, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [normals] = models.utilities.meshPublic.getTriangleNormals(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getTriangleNormals}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{getTriangleQuality: calculate area of triangles}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:getTriangleQuality}AToM:+models:+utilities:+meshPublic:getTriangleQuality         
          \subsection*{getTriangleQuality: calculate area of triangles}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: points coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: node numbers for each triangle, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{quality}}: quality of triangles, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 quality = models.utilities.meshPublic.getTriangleQuality(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}getTriangleQuality}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{healMesh: removes duplicate nodes and triangles}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:healMesh}AToM:+models:+utilities:+meshPublic:healMesh         
          \subsection*{healMesh: removes duplicate nodes and triangles}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 HealMesh utility removes duplicate nodes a triangles from mesh.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: connectivity of nodes, double [N x (2, 3, 4)]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNodes}}: new set of nodes, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newConnectivityList}}: new set of connections, double [N x (2, 3, 4)]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [newNodes, newConnectivityList] =
 models.utilities.meshPublic.healMesh(nodes, connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}healMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{importGeo: imports mesh from GEO files}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:importGeo}AToM:+models:+utilities:+meshPublic:importGeo         
          \subsection*{importGeo: imports mesh from GEO files}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{filePath}}: path to imported file, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: coordinates of points, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: subscripts into nodes, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{fileIsReadable}}: informs whether file can be read, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [nodes, connectivityList, fileIsReadable] =
 models.utilities.meshPublic.importGeo(filePath);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}importGeo}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{importMphtxt: Imports mesh from mphtxt file}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:importMphtxt}AToM:+models:+utilities:+meshPublic:importMphtxt         
          \subsection*{importMphtxt: Imports mesh from mphtxt file}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{fileName}}: name of imported file, char [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: coordinates of points, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: pointers on nodes which represents
  triangles of mesh, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{fileIsReadable}}: informs whether file can be read, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [nodes, connectivityList, fileIsReadable] =
 models.utilities.meshPublic.importMphtxt(fileName);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}importMphtxt}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{importNastran: Imports mesh from NASTRAN file}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:importNastran}AToM:+models:+utilities:+meshPublic:importNastran         
          \subsection*{importNastran: Imports mesh from NASTRAN file}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{fileName}}: name of imported file
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: coordinates of points, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges}}: pointers on nodes which represents edges of mesh, double [N x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: pointers on nodes which represents
  connectivityList of mesh, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{tetrahedrons}}: not used, double [N x 4]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{fileIsReadable}}: informs whether file can be read, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [nodes, edges, connectivityList, tetrahedrons, fileIsReadable] =
 models.utilities.meshPublic.importNastran(filePath);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}importNastran}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{meshToPolygon: creates polygon from mesh}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:meshToPolygon}AToM:+models:+utilities:+meshPublic:meshToPolygon         
          \subsection*{meshToPolygon: creates polygon from mesh}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Creates counter clockwise representation of mesh boundary.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: set of nodes, double [N x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: set of node connections, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{polygons}}: cell of points for each polygon, cell [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{err}}: error when points aren't in one plane, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [polygons] = models.utilities.meshPublic.meshToPolygon(nodes,
 connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}meshToPolygon}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{: }
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:mirrorMesh}AToM:+models:+utilities:+meshPublic:mirrorMesh         
          \subsection*{: }
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Mirrors mesh according to a mirror plane given by its normal.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: mesh nodes, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{normal}}: mirror plane normal, double [1 x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{origin}}: mirror plane origin, double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNodes}}: mesh nodes, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [newNodes] = models.utilities.meshPublic.mirrorMesh(nodes, normal, origin);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}mirrorMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{nodeReferences: counts references of nodes in connectivityList}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:nodeReferences}AToM:+models:+utilities:+meshPublic:nodeReferences         
          \subsection*{nodeReferences: counts references of nodes in connectivityList}
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: double, [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: double [N x (2, 3, 4)]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{countedReferences}}: number represents how many times is each node
  referenced in connectivityList, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isReferenced}}: is node referenced in connectivityList, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{referencedShift}}: shift of values in connectivityList if you
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{take only nodes(isReferenced,}}:), double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [countedReferences, isReferenced, referencedShift] =
 models.utilities.meshPublic.nodeReferences(nodes, connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}nodeReferences}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pixelGridToHexaMesh: generates hexagonal mesh from matrix of indices}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:pixelGridToHexaMesh}AToM:+models:+utilities:+meshPublic:pixelGridToHexaMesh         
          \subsection*{pixelGridToHexaMesh: generates hexagonal mesh from matrix of indices}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Each entry is considered as a pixel of size d (by default d = 1)
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
    M: matrix of integer numbers
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  (optional)
    d: size of the pixel (by default d = 1)
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
    nodes:
    connectivityList:
    Mesh: mesh grid in AToM format
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [nodes, connectivityList, Mesh = ...
        models.utilities.meshPublic.pixelGridToHexaMesh(ones(10, 5), 1);
 \end{Verbatim}
 \begin{Verbatim}
 Type of elementary mesh cells:
  M(i,j) = 0 pixel is filled by void
  M(i,j) = 1 pixel is filled my metalization
 \end{Verbatim}
 \begin{Verbatim}
 One pixel is composed of two adjacent equilateral triangles.
 \end{Verbatim}
 \begin{Verbatim}
 The final mesh is centered around the origin of the coordinate system.
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}pixelGridToHexaMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{pixelGridToOrthoMesh: generates mesh from matrix full of integer numbers}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:pixelGridToOrthoMesh}AToM:+models:+utilities:+meshPublic:pixelGridToOrthoMesh         
          \subsection*{pixelGridToOrthoMesh: generates mesh from matrix full of integer numbers}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Each entry is considered as a pixel of size d (by default d = 1)
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
    M: matrix of integer numbers denoting type of mesh in that pixel
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  (optional)
    d: size of the pixel (by default d = 1)
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
    nodes: triangulation nodes, double [N x 3]
    connectivityList: triangulation connectivity list, double [N x 3]
    Mesh: mesh grid in AToM format
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [nodes, connectivityList, Mesh = ...
        models.utilities.meshPublic.pixelGridToOrthoMesh(ones(10, 5), 1);
 \end{Verbatim}
 \begin{Verbatim}
 Type of elementary mesh cells:
  M(i,j) = +1 pixel has two triangles with "7-2 hours" diagonal
  M(i,j) = -1 pixel has two triangles with "5-11 hours" diagonal
  M(i,j) = +2 pixel has four triangles devided by two diagonals X
 \end{Verbatim}
 \begin{Verbatim}
 The final mesh is centered around the origin of the coordinate system.
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}pixelGridToOrthoMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotMeshBoundary:: plots boudary edges and nodes}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:plotMeshBoundary}AToM:+models:+utilities:+meshPublic:plotMeshBoundary         
          \subsection*{plotMeshBoundary:: plots boudary edges and nodes}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Plots boudary edges and nodes of triangulation given by
 nodes and connectivityList.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: triangle vertices, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 models.utilities.meshPublic.plotMeshBoundary(nodes, connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}plotMeshBoundary}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotMeshCircumsphere: plots mesh and its circumpshere}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:plotMeshCircumsphere}AToM:+models:+utilities:+meshPublic:plotMeshCircumsphere         
          \subsection*{plotMeshCircumsphere: plots mesh and its circumpshere}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 Plots circumsphere of triangulation given by nodes and connectivityList.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: triangle vertices, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 models.utilities.meshPublic.plotMeshCircumsphere(nodes, connectivityList);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}plotMeshCircumsphere}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{rotateMesh: rotates given set of points by given angles}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:rotateMesh}AToM:+models:+utilities:+meshPublic:rotateMesh         
          \subsection*{rotateMesh: rotates given set of points by given angles}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function takes nodes in 3D and rotates them by angles specified
 in angles matrix. The coordinate system is right handed.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: node coordinates, double[N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{angles}}: angles for point rotation, double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNodes}}: nodes rotated by angles, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [newNodes] = models.utilities.meshPublic.rotateMesh(nodes, angles);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}rotateMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{scaleMesh: rotates given set of points by given angles}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:scaleMesh}AToM:+models:+utilities:+meshPublic:scaleMesh         
          \subsection*{scaleMesh: rotates given set of points by given angles}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function takes nodes in 3D and scales them uniformly by given ratio.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: node coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{ratio}}: ratio for scaling points, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNodes}}: points scaled by ratio, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [newNodes] = models.utilities.meshPublic.scaleMesh(nodes, ratio);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}scaleMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{scaleNonUniformMesh: rotates given set of points by given angles}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:scaleNonUniformMesh}AToM:+models:+utilities:+meshPublic:scaleNonUniformMesh         
          \subsection*{scaleNonUniformMesh: rotates given set of points by given angles}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function takes points in 3D and scales them non-uniformly by given ratio.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{ratio}}: ratio for scaling points, double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{p}}: points scaled by ratio, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 p = models.utilities.meshPublic.scaleNonUniformMesh(points, ratio);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}scaleNonUniformMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{Find: IDs of edges contributing to the points}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:searchForEdgeIDs}AToM:+models:+utilities:+meshPublic:searchForEdgeIDs         
          \subsection*{Find: IDs of edges contributing to the points}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Location of all points is compared with location of all edges. The point coordinates are expressed in terms of simplex coordinates of the triangle(s). If the simplex coordinates satisfy all the necessary conditions, it means that the point is touching given edge.\end{par}\begin{Verbatim}
     o-------------------o
    1          a          2
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}searchForEdgeIDs}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{Find: IDs of triangles contributing to the points}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:searchForTriangleIDs}AToM:+models:+utilities:+meshPublic:searchForTriangleIDs         
          \subsection*{Find: IDs of triangles contributing to the points}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Location of all points is compared with location of all triangles. The point coordinates are expressed in terms of simplex coordinates of the triangle(s). If the simplex coordinates satisfy all the necessary conditions, it means that the point is touching area of given trinagle.\end{par}\begin{Verbatim}
               3                  S = triangle area
               o                  S1 = area of triangle "point-2-3"
              /|\                 S2 = area of triangle "point-3-1"
             / | \                S3 = area of triangle "point-1-2"
            /  |  \
           /   |d3 \              d1 = distance to node 1
         c/    |    \b            d2 = distance to node 2
         /  S2 | S1  \            d3 = distance to node 3
        /     _o_     \
       / d1_-     -_d2 \          simplex1,2,3 = simplex coordinates
      /_--     S3    --_\
     o-------------------o
    1          a          2
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}searchForTriangleIDs}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{: }
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:symmetrizeMesh}AToM:+models:+utilities:+meshPublic:symmetrizeMesh         
          \subsection*{: }
 
          \begin{mdframed}
          \vspace{5pt}
          \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: mesh nodes, double [M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: nodes connectivity, double [N x (2, 3, 4)]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{plane}}: symmetry plane, double [3 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNodes}}: mesh nodes, double [M x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newConnectivityList}}: nodes connectivity, double [N x (2, 3, 4)]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mirroredElements}}: [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [newNodes, newConnectivityList, mirroredElements] = models.utilities
    .meshPublic.symmetrizeMesh(nodes, connectivityList, plane);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}symmetrizeMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{testIsMeshValid: tests valid triangle connections}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:testIsMeshValid}AToM:+models:+utilities:+meshPublic:testIsMeshValid         
          \subsection*{testIsMeshValid: tests valid triangle connections}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 testIsMeshValid whether mesh is conforming
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{edges}}: edges connecting nodes, double [N x 2]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{isValid}}: is mesh valid, logical [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [isValid] =
 models.utilities.meshPublic.testIsMeshValid(nodes, edges);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}testIsMeshValid}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{translateMesh: rotates given set of points by given angles}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:translateMesh}AToM:+models:+utilities:+meshPublic:translateMesh         
          \subsection*{translateMesh: rotates given set of points by given angles}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function takes nodes in 3D and translates them by given
 vector specified in variable shift.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: node coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{shift}}: vector for translation, double [1 x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNodes}}: nodes translated by shift, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [newNodes] = models.utilities.meshPublic.translateMesh(nodes, shift);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}translateMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{uniformTriangulation2D: creates regular uniform triangulation over given polygon in 3D}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:uniformTriangulation2D}AToM:+models:+utilities:+meshPublic:uniformTriangulation2D         
          \subsection*{uniformTriangulation2D: creates regular uniform triangulation over given polygon in 3D}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function takes boundary nodes of polygon which should be meshed.
 Boundary and hole points must be ordered counter clockwise.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{boundaryNodes}}: point coordinates, double [N x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{holes}}: a cell with points of holes, might be an empty cell, cell [1 x 1]
    containint matrices double [N x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{elemSize}}: euclidean distance between points, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{meshType}}: type of triangles used for meshing, string [1 x N]
            options: right, equilateral
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: new set of nodes, double [N x 2]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: new set of connections, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [nodes, connectivityList] = models.utilities.meshPublic.
    uniformTriangulation2D(boundaryPoints, holes, elemSize, meshType);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}uniformTriangulation2D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{uniformTriangulation3D: creates regular uniform triangulation over given polygon in 3D}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:uniformTriangulation3D}AToM:+models:+utilities:+meshPublic:uniformTriangulation3D         
          \subsection*{uniformTriangulation3D: creates regular uniform triangulation over given polygon in 3D}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function takes boundary nodes of polygon which should be meshed.
 Boundary and hole points must be ordered counter clockwise.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{boundaryNodes}}: point coordinates, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{holes}}: a cell with points of holes, might be an empty cell, cell [1 x 1]
    containint matrices double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{elemSize}}: euclidean distance between points, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{meshType}}: type of triangles used for meshing, char [1 x N]
            options: right, equilateral
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes}}: new set of nodes, double [N x 3]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList}}: new set of connections, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [nodes, connectivityList] = models.utilities.meshPublic.
    uniformTriangulation3D(boundaryPoints, holes, elemSize, meshType);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}uniformTriangulation3D}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{uniquetol: Unique values with tolerance}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:uniquetol}AToM:+models:+utilities:+meshPublic:uniquetol         
          \subsection*{uniquetol: Unique values with tolerance}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function is fallback for versions of Matlab (<2015a) which don't have
 built-in uniquetol.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{toUnique}}: elements to unique, double [N x X]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{epsilon}}: tolerance, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{param1}}: ByRows parameter, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{val1}}: value of parameter 1, logical [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{res}}: unique elements from toUnique, double [N x X]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{ia}}:
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [res, ia, ic] = models.utilities.meshPublic.uniquetol(toUnique, epsilon,
 param1, val1);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}uniquetol}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{uniquetol: Unique values with tolerance and outputs are in the original order}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:uniquetolSorted}AToM:+models:+utilities:+meshPublic:uniquetolSorted         
          \subsection*{uniquetol: Unique values with tolerance and outputs are in the original order}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function is fallback for versions of Matlab (<2015a) which don't have
 built-in uniquetol.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{toUnique}}: elements to unique, double [N x X]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{epsilon}}: tolerance, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{param1}}: ByRows parameter, char [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{val1}}: value of parameter 1, logical [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{res}}: unique elements from toUnique, double [N x X]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{ia}}:
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [res, ia, ic] = models.utilities.meshPublic.uniquetolSorted(toUnique,
 epsilon, param1, val1);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}uniquetolSorted}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{uniteMeshes: creates one mesh from 2 sets of nodes and connectivity lists}
          \vspace{1em}
          \label{AToM:+models:+utilities:+meshPublic:uniteMeshes}AToM:+models:+utilities:+meshPublic:uniteMeshes         
          \subsection*{uniteMeshes: creates one mesh from 2 sets of nodes and connectivity lists}
 
          \begin{mdframed}
          \vspace{5pt}
          \begin{Verbatim}
 This function connects two meshes into one connectivity list and one unique
 set of nodes.
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes1}}: node coordinates 1, double [N x X]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList1}}: nodes1 connectivity, double [N x X]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nodes2}}: node coordinates 2, double [N x X]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{connectivityList2}}: nodes2 connectivity, double [N x X]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newNodes}}: unique set of nodes, double [N x X]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newConnectivityList}}: new connectivity List, double [N x X]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [newNodes, newConnectivityList] = models.utilities.meshPublic.
    uniteMeshes(nodes1, connectivityList1, nodes2, connectivityList2);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+meshPublic\ensuremath{\backslash}uniteMeshes}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +models/+utilities/+subregionMatrices}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+models/+utilities/+subregionMatrices}}~}
\fancyhead[RO,RE]{+models/+utilities/+subregionMatrices}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{computeCMat: computes subregion matrix C}
          \vspace{1em}
          \label{AToM:+models:+utilities:+subregionMatrices:computeCMat}AToM:+models:+utilities:+subregionMatrices:computeCMat         
          \subsection*{computeCMat: computes subregion matrix C}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Computes subregion matrix C which can be use to 'cut' any vector/matrix quantity connected to given mesh and basis functions structure. C matrix allows to reduce any vector/matrix quantity and cut out any part of the structure or create 'holes' into structure which is described by this matrix, these parts are defined by one or more polygons.\end{par}\vspace{2pt}\begin{par}Properies of C matrix:\end{par}\begin{Verbatim}
     zMatSmall = C' * zMatBig * C
     ISmall = C' * IBig
     IBig = C * ISmall
 \end{Verbatim}
 \vspace{2pt}\begin{par}where\end{par}\begin{Verbatim}
 zMatBig   - impedance matrix of full structure,
 zMatSmall - impedance matrix of structure with 'holes',
 IBig      - vector of expansion coefficient which belongs to zMatBig,
 ISmall    - reduced vector of expansion coefficients which belongs
             to zMatSmall
 \end{Verbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions struct created by AToM, struct [1 x 1],
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{polygons}}:  cell of polygons defined by border points, cell[N x 1]
              N ~ number of polygons
              polygons are defined by border points using coordinates
              [x, y], double [M x 2]
              M ~ number of border points
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{type}}:      type of cut flag, double [1 x 1],
              \ensuremath{>}= 0 \ensuremath{\tilde{\;}} cut out part of the structure (positive cut)
              \ensuremath{<} 0  \ensuremath{\tilde{\;}} create 'holes' into the structure (negative cut)
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{C}}:               subregion matrix, double [P X Q]
                    P ~ size of 'big' quantity
                    Q ~ size of 'small' quantity
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newMesh}}:         new mesh structure, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{newBasisFcns}}:    basis functions struct, modified to be in proper
                   order to 'small' quantities, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcnsOrder}}:  vector which describes new order of basis funtions
                   corresponding to 'small' quantities, double [Q x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [C, newMesh] = computePositiveCMat(mesh, basisFcns, polygons)
 [C, newMesh, newBasisFcns] = computePositiveCMat( ...
   mesh, basisFcns, polygons, 1)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+models\ensuremath{\backslash}+utilities\ensuremath{\backslash}+subregionMatrices\ensuremath{\backslash}computeCMat}}
       
       
       
       \vspace{2em}
       
    \cleardoublepage\phantomsection\addcontentsline{toc}{chapter}{Namespace +results}\mbox{}{\vfill\hfill\Huge\rotatebox{90}{\quad\textcolor{gray}{Namespace}}~\rotatebox{90}{\quad\textbf{+results}}~}
\fancyhead[RO,RE]{+results}\newpage

          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateCharacteristicAngle: calculate characteristic angle from eigennumber}
          \vspace{1em}
          \label{AToM:+results:calculateCharacteristicAngle}AToM:+results:calculateCharacteristicAngle         
          \subsection*{calculateCharacteristicAngle: calculate characteristic angle from eigennumber}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Calculates characteristic angle.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigennumber}}:  eigen numbers, double [N x M]
                 N - number of modes
                 M - number of frequencies
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{characteristicAngle}}:  characteristic angles, double [N x M]
                         N - number of modes
                         M - number of frequencies
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 characteristicAngle = calculateCharacteristicAngle(eigennumber)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateCharacteristicAngle}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateCharge: calculate charge density on given structure}
          \vspace{1em}
          \label{AToM:+results:calculateCharge}AToM:+results:calculateCharge         
          \subsection*{calculateCharge: calculate charge density on given structure}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Calculates charge distribution.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{iVec}}:      vector of expansion coeficients from AToM MoM,
             double [N x 1]
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (optional)
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}:   Cartesian coordinates of the points, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{divJ}}:     divergence of the current density, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}:   Cartesian coordinates of the points, double [N x 3]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 divJ = results.calculateCharge(mesh, basisFcns, iVec)
 [divJ, points] = results.calculateCharge(mesh, basisFcns, iVec, points)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateCharge}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateCurrent: calculate current density on given structure}
          \vspace{1em}
          \label{AToM:+results:calculateCurrent}AToM:+results:calculateCurrent         
          \subsection*{calculateCurrent: calculate current density on given structure}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Calculates current density from given results comming from MOM.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{iVec}}:      vector of expansion coeficients from AToM MoM,
              double [N x 1]
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  (optional)
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}:   Cartesian coordinates of the points, double [N x 3]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Jx}}:       x component of the current density, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Jy}}:       y component of the current density, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Jz}}:       z component of the current density, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{points}}:   Cartesian coordinates of the points, double [N x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [Jx, Jy, Jz] = results.calculateCurrent(mesh, basisFcns, iVec)
 [Jx, Jy, Jz, points] = results.calculateCurrent(mesh, basisFcns, ...
                        iVec, points)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateCurrent}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateCurrentDecomposition: calculates current decoposition}
          \vspace{1em}
          \label{AToM:+results:calculateCurrentDecomposition}AToM:+results:calculateCurrentDecomposition         
          \subsection*{calculateCurrentDecomposition: calculates current decoposition}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}This decomposition is based on S matatrix which is defined in \url{https://arxiv.org/pdf/1709.09976.pdf}.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{iVec}}:      vector of expansion coeficients, double [M x N]
              M - number of basis functions
              N - number of frequency points
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: vector of frequencies, double [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'maxDegreeL'       maximal degree of used spherical harmonics,
                      double [1 x 1], default: 5
  'quadratureOrder'  used gaussian quadrature order in integration,
                      double [1 x 1], integer <1, 12>, default: 1
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{decomposition}}:   decomposition matrix, double [N x M]
                    N - number of used modes
                    M - number of frequencies
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{indexMatrix}}:     indexation matrix used to identify modes,
                    double [5 x N]
                    N - number of used modes
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 decomposition = results.calculateCurrentDecomposition(mesh, ...
    basisFcns, iVec, frequency)
 [decomposition, I] = results.calculateCurrentDecomposition(mesh, ...
    basisFcns, iVec, frequency, 'maxDegreeL', 10, 'quadratureOrder', 2);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateCurrentDecomposition}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateEigennumber: calculates eigennumber from characteristic angle}
          \vspace{1em}
          \label{AToM:+results:calculateEigennumber}AToM:+results:calculateEigennumber         
          \subsection*{calculateEigennumber: calculates eigennumber from characteristic angle}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Calculates eigennumbers.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{characteristicAngle}}:     characteristic angles, double [N x M]
                            N - number of modes
                            M - number of frequencies
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{eigennumber}}:             eigen numbers, double [N x M]
                            N - number of modes
                            M - number of frequencies
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 eigennumber = calculateEigennumber(characteristicAngle)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateEigennumber}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateFarField: computes far-field for given structure and current}
          \vspace{1em}
          \label{AToM:+results:calculateFarField}AToM:+results:calculateFarField         
          \subsection*{calculateFarField: computes far-field for given structure and current}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Calculates far-field.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: value of frequency, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'basisFcns'  basis functions struct created by AToM, struct [1 x 1]
  'iVec'       vector of expansion coeficients, double [N x 1]
  'theta'      vector of points in theta spherical coordinate,
                double [1 x N], default: linspace(0, pi, 46)
  'phi'        vector of points in phi spherical coordinate,
                double [1 x N], default: linspace(0, 2*pi, 91)
  'J'          current density to be plotted, double [N x 3]
  'Jx'         x component of current density to be plotted,
                double [N x 1]
  'Jy'         y component of current density to be plotted,
                double [N x 1]
  'Jz'         z component of current density to be plotted,
                double [N x 1]
  'quadOrder'  quadrature order, double [1 x 1]]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{farFieldStructure}}:   structure with all computed quantities,
                        struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 farFieldStructure = results.calculateFarField(mesh, frequency, ...
   'basisFcns', basisFcns);
 farFieldStructure = results.calculateFarField(mesh, frequency, ...
   'basisFcns', basisFcns, 'theta', linspace(0, pi, 46), ...
   'phi', linspace(0, 2*pi, 91));
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateFarField}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateNearField: computes near-field for given structure and current}
          \vspace{1em}
          \label{AToM:+results:calculateNearField}AToM:+results:calculateNearField         
          \subsection*{calculateNearField: computes near-field for given structure and current}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Calculates near-field.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{iVec}}:      vector of expansion coeficients, double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: value of frequency, double [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{uPoints}}:   vector of points in first dimension, double [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{vPoints}}:   vector of points in secont dimension, double [1 x M]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{plane}}:     near field plane, {'x', 'y', 'z'}
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{distance}}:  perpendicular distance from origin, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{nearFieldStructure}}:   structure with all computed quantities,
                         struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 nearFieldStructure = results.calculateNearField(mesh, basisFcns, ...
    iVec, frequency, uPoints, vPoints, plane, distance)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateNearField}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateQFBW: computes Q\_FBW}
          \vspace{1em}
          \label{AToM:+results:calculateQFBW}AToM:+results:calculateQFBW         
          \subsection*{calculateQFBW: computes Q\_FBW}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Calculates quality factor Q\_FBW.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{zIn}}:       input impedance, double [N x 1]
              N - number of frequencies
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: frequency list, double [N x 1], [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{alpha}}:     FBW threshold, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{QFBW}}:      quality factor QFBW, double [M x 1]
  f          frequencies corresponding to QFBW, double [M x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [QFBW, f] = results.calculateQFBW(zIn, frequency, alpha)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateQFBW}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateQZ: computes Q\_Z}
          \vspace{1em}
          \label{AToM:+results:calculateQZ}AToM:+results:calculateQZ         
          \subsection*{calculateQZ: computes Q\_Z}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Calculates quality factor Q\_Z.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{zIn}}:       input impedance, double [N x 1]
              N - number of frequencies
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: frequency list, double [N x 1], [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{QZ}}:      quality factor QZ, double [M x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{QZTuned}}: quality factor QZ tuned to resonance, double [M x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [QZ, QZTuned] = results.calculateQZ(zIn, frequency)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateQZ}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateRCS: computes monostatic/bistatic radar cross section}
          \vspace{1em}
          \label{AToM:+results:calculateRCS}AToM:+results:calculateRCS         
          \subsection*{calculateRCS: computes monostatic/bistatic radar cross section}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Calculates RCS.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{iVec}}:      vector of expansion coeficients from AToM MoM,
              double [N x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: value of frequency, double [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'theta'     vector of points in theta spherical coordinate,
               double [1 x N], default: linspace(0, pi, 46)
  'phi'       vector of points in phi spherical coordinate,
               double [1 x M], default: linspace(0, 2*pi, 91)
  'component' specify componenit of used radiation intesity,
               char [1 x N], {'theta', 'phi', 'total'}, default: 'total'
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{RCS}}:   radar cross section (RCS), double [N x M]
          N - number of points in theta
          M - number of points in phi
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{theta}}: vector of points in theta spherical coordinate, double [1 x N]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{phi}}:   vector of points in phi spherical coordinate, double [1 x M]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 [RCS, theta, phi] = calculateRCS(mesh, basisFcns, iVec, frequency);
 [RCS, theta, phi] = calculateRCS(mesh, basisFcns, iVec, frequency, ...
   'component', 'theta');
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateRCS}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{calculateS: computes s parameter from z parameters}
          \vspace{1em}
          \label{AToM:+results:calculateS}AToM:+results:calculateS         
          \subsection*{calculateS: computes s parameter from z parameters}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Calculates S parameters.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{zIn}}:       input impedance, double [N x N x M]
              N - number of ports
              M - number of frequencies
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'z0'       characteristic impedance, double [1 x 1], default 50 Ohm
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{S}}:         s parameters, double [N x N x M]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 S = results.calculateS(zIn);
 S = results.calculateS(zIn, 'z0', 50);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}calculateS}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotBasisFcns: generates plot of given basis functions}
          \vspace{1em}
          \label{AToM:+results:plotBasisFcns}AToM:+results:plotBasisFcns         
          \subsection*{plotBasisFcns: generates plot of given basis functions}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of basis functions.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{basisFcns}}: basis functions struct created by AToM, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'options'     ploting options, list below, struct [1 x 1]
  'handles'     handles to the modification, struct [1 x 1]
  'template'    template containing graphic rules, struct [1 x 1]
 \end{IOVerbatim}
 \begin{Verbatim}
 Options structure, logical [1 x 1] in each field
  options.showBasisFcns         generate basis functions
  options.showBasisFcnsNumbers  generate numbers of basis functions
 \end{Verbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 handles = results.plotBasisFcns(mesh, basisFcns)
 handles = results.plotBasisFcns(mesh, basisFcns, 'options', options)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotBasisFcns}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotCharacteristicAngle: generates plot of given characteristic angle}
          \vspace{1em}
          \label{AToM:+results:plotCharacteristicAngle}AToM:+results:plotCharacteristicAngle         
          \subsection*{plotCharacteristicAngle: generates plot of given characteristic angle}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of characteristic angle.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'characteristicAngle'     characteristic angles, double [N x M]
                             N - number of modes
                             M - number of frequencies
  'eigennumber'             eigen numbers, double [N x M]
                             N - number of modes
                             M - number of frequencies
  'frequency'               frequency list, double [M x 1]
  'handles'                 handles to the modification, struct [1 x 1]
  'template'                template containing graphic rules,
                             struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 handles = results.plotCharacteristicAngle('frequency', frequency, ...
   'characteristicAngle', characteristicAngle);
 handles = results.plotCharacteristicAngle('frequency', frequency, ...
   'eigennumber', eigennumber);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotCharacteristicAngle}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotCharge: generates plot of charge density on given structure}
          \vspace{1em}
          \label{AToM:+results:plotCharge}AToM:+results:plotCharge         
          \subsection*{plotCharge: generates plot of charge density on given structure}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of charge density.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'basisFcns'   basis functions struct created by AToM, struct [1 x 1]
  'iVec'        vector of expansion coeficients, double [N x 1]
  'divJ'        vector of charge computed in triangle centroid,
                 double [N x 1]
  'divJnodes'   vector of charge computed in mesh nodes, double [N x 1]
  'part'        part of plotted current, \{'re', 'im', 'abs'\}
  'options'     ploting options, list below, struct [1 x 1]
  'handles'     handles to the modification, struct [1 x 1]
  'template'    template containing graphic rules, struct [1 x 1]
 \end{IOVerbatim}
 \begin{Verbatim}
 Options structure, logical [1 x 1] in each field
  options.showCharge             generate triangles with color map
                                according to calculated charge density
  options.colorbar               show colorbar
 \end{Verbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 handles = results.plotCharge(mesh, basisFcns, iVec)
 handles = results.plotCharge(mesh, basisFcns, iVec)
 handles = results.plotCharge(mesh, basisFcns, iVec, 'part', 'abs')
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotCharge}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotCurrent: Generates plot of current density on given structure}
          \vspace{1em}
          \label{AToM:+results:plotCurrent}AToM:+results:plotCurrent         
          \subsection*{plotCurrent: Generates plot of current density on given structure}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of current density.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'basisFcns'   basis functions struct created by AToM, struct [1 x 1]
  'iVec'        vector of expansion coeficients, double [N x 1]
  'J'           current density to be plotted, double [N x 3]
  'Jnodes'      current density to be plotted computed in mesh nodes,
                 double [N x 3], important for interpolated colors
  'Jx'          x component of current density to be plotted,
                 double [N x 1]
  'Jy'          y component of current density to be plotted,
                 double [N x 1]
  'Jz'          z component of current density to be plotted,
                 double [N x 1]
  'part'        part of plotted current, \{'re', 'im', 'abs'\}
  'scale'       sets the scale of the color map,
                 \{'linear', 'normalized','logarithmic'\}
  'arrowScale'  sets the scale of the arrows,
                 \{'uniform', 'proportional'\}
  'arrowLength' sets maximal absolute length of arrow, double [1 x 1]
  'options'     ploting options, list below, struct [1 x 1]
  'handles'     handles to the modification, struct [1 x 1]
  'template'    template containing graphic rules, struct [1 x 1]
 \end{IOVerbatim}
 \begin{Verbatim}
 Options structure, logical [1 x 1] in each field
  options.showCurrentIntensity   generate triangles with color map
                                accordingto calculated current density
  options.showCurrentArrows      generate arrows according to current
                                density
  options.colorbar               show colorbar
 \end{Verbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 results.plotCurrent(mesh, 'basisFcns', basisFcns, 'iVec', iVec)
 handles = results.plotCurrent(mesh, 'basisFcns', basisFcns, 'iVec', ...
  iVec)
 handles = results.plotCurrent(mesh,  'basisFcns', basisFcns, ...
  'iVec', iVec, 'part', 'abs', 'scale', 'linear')
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotCurrent}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotCurrentDecomposition: generates plot of current decomposition}
          \vspace{1em}
          \label{AToM:+results:plotCurrentDecomposition}AToM:+results:plotCurrentDecomposition         
          \subsection*{plotCurrentDecomposition: generates plot of current decomposition}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of current decomposition.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'decomposition'   decomposition matrix, double [N x M]
                     N - number of used modes
                     M - number of frequencies
  'indexMatrix'     indexation matrix used to identify modes,
                     double [5 x N]
                     N - number of used modes
  'frequency'       frequency list, double [M x 1]
  'mesh'            mesh struct created by AToM, struct [1 x 1]
  'basisFcns'       basis functions struct created by AToM, struct [1 x 1]
  'iVec'            vector of expansion coeficients, double [N x 1]
  'threshold'       threshold to filter modes, double [1 x 1]
  'options'         ploting options, list below, struct [1 x 1]
  'handles'         handles to the modification, struct [1 x 1]
  'template'        template containing graphic rules, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 handles = results.plotCurrentDecomposition('mesh', mesh, ...
   'basisFcns', basisFcns, 'iVec', iVec, 'frequency', frequency)
 handles = results.plotCurrentDecomposition( ...
   'decomposition', decomposition, 'frequency', frequency)
 handles = results.plotCurrentDecomposition( ...
   'decomposition', decomposition, 'indexMatrix', indexMatrix, ...
   'frequency', frequency)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotCurrentDecomposition}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotEigennumber: generates plot of given eigen numbers}
          \vspace{1em}
          \label{AToM:+results:plotEigennumber}AToM:+results:plotEigennumber         
          \subsection*{plotEigennumber: generates plot of given eigen numbers}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of eigennumbers.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'eigennumber'             eigen numbers, double [N x M]
                             N - number of modes
                             M - number of frequencies
  'characteristicAngle'     characteristic angles, double [N x M]
                             N - number of modes
                             M - number of frequencies
  'frequency'               frequency list, double [M x 1]
  'handles'     handles to the modification, struct [1 x 1]
  'template'    template containing graphic rules, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 handles = results.plotEigennumbers('frequency', frequency, ...
   'eigennumber', eigennumber);
 handles = results.plotEigennumbers('frequency', frequency, ...
   'characteristicAngle', characteristicAngle);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotEigennumber}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotFarField: generates plot of far-field}
          \vspace{1em}
          \label{AToM:+results:plotFarField}AToM:+results:plotFarField         
          \subsection*{plotFarField: generates plot of far-field}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of far-field.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'mesh'          mesh struct created by AToM, struct [1 x 1]
  'basisFcns'     basis functions struct created by AToM, struct [1 x 1]
  'iVec'          vector of expansion coeficients, double [N x 1]
  'theta'         vector of points in theta spherical coordinate,
                   double [1 x N]
  'phi'           vector of points in phi spherical coordinate,
                   double [1 x N]
  'frequency'     value of frequency, double [1 x 1]
  'farField'      data for given theta and phi, double [N x M]
  'options'       ploting options, list below, struct [1 x 1]
  'handles'       handles to the modification, struct [1 x 1]
  'template'      template containing graphic rules, struct [1 x 1]
  'radius'        value for scaling size of plotted far-field,
                   double [1 x 1]
  'userFunction'  function handle used to choose what to plot,
                   function handle [1 x 1],
                   default function @(ff) abs(ff.D)
 \end{IOVerbatim}
 \begin{Verbatim}
 Options structure, logical [1 x 1] in each field
  options.showFarField               generate surface of far-field
  options.showSphericalCoordinates   generate spherical coordinates to
                                    figure
  options.showCartesianCoordinates   generate cartesian coordinates to
                                    figure
  options.showColorBar               show colorbar
 \end{Verbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 handles = results.plotFarField('mesh', mesh, 'basisFcns', bf, ...
  'iVec', iVec, 'frequency', frequency);
 handles = results.plotFarField('theta', thetaVector, ...
 'phi', phiVector, 'farField', farFieldMatrix)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotFarField}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotFarFieldCut: generates plot of far-field cut}
          \vspace{1em}
          \label{AToM:+results:plotFarFieldCut}AToM:+results:plotFarFieldCut         
          \subsection*{plotFarFieldCut: generates plot of far-field cut}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of far-field cut.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'farField'    data for given theta and phi, double [N x M]
  'theta'       vector of points in theta spherical coordinate,
               double [1 x N]
  'phi'         vector of points in phi spherical coordinate,
               double [1 x N]
  'thetaCut'    value of theta for cut in theta, double [1 x 1]
  'phiCut'      value of phi for cut in phi, double [1 x 1]
  'handles'     handles to the modification, struct [1 x 1]
  'template'    template containing graphic rules, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 \vspace{2pt}\begin{par}SYNTAX\end{par}\begin{Verbatim}
 results.plotFarFieldCut('farField', farField, 'theta', theta, ...
   'phi', phi, 'thetaCut', thetaCut);
 handles = results.plotFarField('farField', farField, 'theta', theta, ...
  'phi', phi, 'thetaCut', thetaCut);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotFarFieldCut}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotMesh: generates plot of given structure}
          \vspace{1em}
          \label{AToM:+results:plotMesh}AToM:+results:plotMesh         
          \subsection*{plotMesh: generates plot of given structure}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of mesh.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{mesh}}:      mesh struct created by AToM, struct [1 x 1]
 \end{IOVerbatim}
 \begin{Verbatim}
 Options structure, logical [1 x 1] in each field
  options.showNodes             generate point for each node
  options.showNodeNumbers       generate numbers of nodes
  options.showEdges             generate edges (line object)
  options.showEdgesNumbers      generate numbers of edges
  options.showEdgesArrows       generate arrows to show orientation of
                                 edges
  options.showTriangles         generate triangles (patch object)
  options.showTriangleNumbers   generate numbers of triangles
 \end{Verbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 handles = results.plotMesh(mesh)
 handles = results.plotMesh(mesh, 'options', options)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotMesh}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotNearField: generates plot of near-field}
          \vspace{1em}
          \label{AToM:+results:plotNearField}AToM:+results:plotNearField         
          \subsection*{plotNearField: generates plot of near-field}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of near-field.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'mesh'          mesh struct created by AToM, struct [1 x 1]
  'basisFcns'     basis functions struct created by AToM, struct [1 x 1]
  'iVec'          vector of expansion coeficients, double [N x 1]
  'frequency'     value of frequency, double [1 x 1]
  'uPoints'       vector of points in first dimension, double [1 x N]
  'vPoints'       vector of points in secont dimension, double [1 x M]
  'plane'         near field plane, \{'x', 'y', 'z'\}
  'distance'      perpendicular distance from origin, double [1 x 1]
  'nearField'     data for given uPoints and vPoints, double [N x M]
  'options'       ploting options, list below, struct [1 x 1]
  'handles'       handles to the modification, struct [1 x 1]
  'template'      template containing graphic rules, struct [1 x 1]
  'userFunction'  function handle used to choose what to plot,
                   function handle [1 x 1], default function @(nf) nf.E
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 handles = results.plotNearField('nearField', nearField, ...
   'uPoints', uPoints,  'vPoints', vPoints, 'plane', 'x', ...
   'distance', distance);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotNearField}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotQ: generates plot of quality factor Q}
          \vspace{1em}
          \label{AToM:+results:plotQ}AToM:+results:plotQ         
          \subsection*{plotQ: generates plot of quality factor Q}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of Q factor.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{Q}}:         quality factor Q, double [N x 1]
              N - number of frequencies
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{frequency}}: vector of frequencies, double [1 x N]
 \end{IOVerbatim}
 \subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'handles'       handles to the modification, struct [1 x 1]
  'template'      template containing graphic rules, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 handles = results.plotQ(Q, frequency)
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotQ}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotRCS: generates plot of monostatic/bistatic radar cross section}
          \vspace{1em}
          \label{AToM:+results:plotRCS}AToM:+results:plotRCS         
          \subsection*{plotRCS: generates plot of monostatic/bistatic radar cross section}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of RCS.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'mesh'                mesh struct created by AToM, struct [1 x 1]
  'basisFcns'           basis functions struct created by AToM,
                         struct [1 x 1]
  'iVec'                vector of expansion coeficients, double [N x 1]
  'theta'               vector of points in theta spherical coordinate,
                         double [1 x N]
  'phi'                 vector of points in phi spherical coordinate,
                         double [1 x N]
  'frequency'           value of frequency, double [1 x N]
  'component'           specify componenit of used radiation intesity,
                         char [1 x N],
                         {'theta', 'phi', 'total'}, default: 'total'
  'RCS'                 data for given theta and phi, double [L x M x N]
                         L - number of points in theta
                         M - number of points in phi
                         N - number of frequencies
  'independentVariable' variable on x axis, char [1 x N]
                         {'theta', 'phi', 'frequency'}, default: 'theta'
  'fixedDimensionTheta' value of fixed dimension theta, double [1 x 1]
  'fixedDimensionPhi'   value of fixed dimension theta, double [1 x 1]
  'options'             ploting options, list below, struct [1 x 1]
  'handles'             handles to the modification, struct [1 x 1]
  'template'            template containing graphic rules, struct [1 x 1]
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 results.plotRCS('RCS', RCS, 'theta', theta, 'phi', phi, ...
   'independentVariable', 'theta', 'fixedDimensionPhi', pi);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotRCS}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{plotS: generates plot of s parameters}
          \vspace{1em}
          \label{AToM:+results:plotS}AToM:+results:plotS         
          \subsection*{plotS: generates plot of s parameters}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Creates plot of S parameters.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
 (parameters)
  'zIn'         input impedance, double [N x N x M]
                 N - number of ports
                 M - number of frequencies
  'z0'          characteristic impedance, double [1 x 1], default 50 Ohm
  's'            s parameters, double [N x N x M]
  'frequency'   list of frequencies, double [M x 1], [1 x M]
  'select'      selection of visualised curves, double [P x 1]
                 selection is based on MATLAB linear indexing
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{'scale'       select scale, char {'linear', 'dB'}, default}}: 'linear'
 \end{IOVerbatim}
 \subsubsection*{Outputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:   structure with all graphic objects, struct [1 x 1]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 handles = results.plotS('frequency', frequency, 'zIn', zIn, 'z0', 50);
 handles = results.plotS('frequency', frequency, 's', S);
 handles = results.plotS('frequency', frequency, 's', S, 'select', 1);
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}plotS}}
       
       
       
       \vspace{2em}
       
    
          \begin{minipage}{\textwidth}
          \cleardoublepage\phantomsection\addcontentsline{toc}{subsection}{standardizeFigure: standardize figure appearance}
          \vspace{1em}
          \label{AToM:+results:standardizeFigure}AToM:+results:standardizeFigure         
          \subsection*{standardizeFigure: standardize figure appearance}
 
          \begin{mdframed}
          \vspace{5pt}
          \vspace{2pt}\begin{par}Controls the appearance of figure and ensures the normalization of the figure. Default profile is saved in results.figureProfiles. Another profile can be created. Create your own profile, place it to .\ensuremath{\backslash}+results\ensuremath{\backslash}+figureProfiles folder and then call it by its name.\end{par}\subsubsection*{Inputs}
 \begin{IOVerbatim}
 
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{handles}}:          structure of graphical objects, struct [1 x 1]
  \end{IOVerbatim}
 \begin{IOVerbatim}
  \textbf{\textcolor{special2}{userProfileName}}:  structure of graphical preferences, struct [ 1 x 1]
                     or name of figureProfile, char [1 x N]
 \end{IOVerbatim}
 
                   \subsubsection*{Syntax}\fvset{formatcom=\color{basic3},fontseries=b}
                \begin{Verbatim}
 standardizeFigure(handles)
 standardizeFigure(handles, 'userProfileName')
 \end{Verbatim}
 
          \vspace{5pt}
          \end{mdframed}
          \end{minipage}
       
       \fancyhead[RO,RE]{\small{AToM\ensuremath{\backslash}+results\ensuremath{\backslash}standardizeFigure}}
       
       
       
       \vspace{2em}
       
    \end{document}
